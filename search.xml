<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>20道vue面试题</title>
    <url>/2022/02/20/20%E9%81%93vue%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>常见的vue面试题，整理如下：<br><a id="more"></a></p>
<h3 id="单页应用-spa"><a href="#单页应用-spa" class="headerlink" title="单页应用(spa)"></a>单页应用(spa)</h3><p>单页Web应用，就是只有一张Web页面的应用。浏览器一开始会加载必需的HTML、CSS和JavaScript，之后所有的操作都在这张页面完成，这一切都由JavaScript来控制。</p>
<p>单页应用得优势：</p>
<p>操作体验流畅，媲美本地应用的感觉，切换过程中不会频繁有被“打断”的感觉。<br>因为界面框架都在本地，与服务端的通讯基本只有数据，所以便于迁移，可以用比较小的代价，迁移成桌面产品，或者各种移动端Hybrid产品。<br>完全的前端组件化，前端开发不再以页面为单位，更多地采用组件化的思想，代码结构和组织方式更加规范化，便于修改和调整；<br>API 共享，如果你的服务是多端的（浏览器端、Android、iOS、微信等），单页应用的模式便于你在多个端共用 API，可以显著减少服务端的工作量。容易变化的 UI 部分都已经前置到了多端，只受到业务数据模型影响的 API，更容易稳定下来，便于提供更棒的服务；<br>组件共享，在某些对性能体验要求不高的场景，或者产品处于快速试错阶段，借助于一些技术（Hybrid、React Native），可以在多端共享组件，便于产品的快速迭代，节约资源。</p>
<p>单页应用得缺点：</p>
<p>首次加载大量资源，要在一个页面上为用户提供产品的所有功能，在这个页面加载的时候，首先要加载大量的静态资源，这个加载时间相对比较长；<br>对搜索引擎不友好，因为界面的绝大部分都是动态生成的，所以搜索引擎很不容易索引它。<br>开发难度相对较高，开发者的JavaScript技能必须过关，同时需要对组件化、设计模式有所认识，他所面对的不再是一个简单的页面，而是一个运行在浏览器环境中的桌面软件。</p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>MVVM全名是 Model View View-Model的缩写<br>Model(模型)：是用于处理应用程序数据逻辑部分。<br>View(视图)：是应用程序中处理数据显示的本分。通常视图是依据模型数据创建的<br>ViewModel层：做了两件事达到了数据的双向绑定，一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。 实现的方式时：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转换成后端的数据。实现的方式是：DOM事件监听。</p>
<h3 id="Vue-的响应式原理（双向数据绑定）"><a href="#Vue-的响应式原理（双向数据绑定）" class="headerlink" title="Vue 的响应式原理（双向数据绑定）"></a>Vue 的响应式原理（双向数据绑定）</h3><p>整体思路是数据劫持 + 观察者模式</p>
<p>对象内部通过 defineReactive 方法，使用 Object.defineProperty 将属性进行劫持（只会劫持已存在的属性），数组则是通过重写数组来实现。当页面使用对应属性时，每个属性都拥有自己的 dep 属性，存在它所依赖的 watcher （依赖收集）get，当属性变化后会通知自己对应的 watcher 去更新（派发更新）set。</p>
<p>1、Object.defineProperty 数据劫持<br>2、使用 getter 收集依赖 ，setter 通知 watcher派发更新。<br>3、watcher 发布订阅模式。</p>
<h3 id="data-为什么是函数"><a href="#data-为什么是函数" class="headerlink" title="data 为什么是函数"></a>data 为什么是函数</h3><p>组件的data写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一分新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果</p>
<h3 id="v-model-的原理"><a href="#v-model-的原理" class="headerlink" title="v-model 的原理"></a>v-model 的原理</h3><p>v-model 只是语法糖而已。<br>v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件。<br>text 和 textarea 元素使用 value property 和 input 事件；<br>checkbox 和 radio 使用 checked property 和 change事件；<br>select 字段将 value 作为 prop 并将 change 作为事件。<br>注意：对于需要使用输入法的语言，你会发现 v-model 不会在输入法组合文字过程中得到更新。<br>在普通元素上：<br>input v-model=’sth’<br>input v-bind:value=’sth’ v-on:input=’sth = $event.target.value’</p>
<h3 id="v-if-和-v-show-的区别"><a href="#v-if-和-v-show-的区别" class="headerlink" title="v-if 和 v-show 的区别"></a>v-if 和 v-show 的区别</h3><p>控制手段不同<br>编译过程不同<br>编译条件不同</p>
<p>控制手段：v-show隐藏则是为该元素添加css–display:none，dom元素依旧还在。v-if显示隐藏是将dom元素整个添加或删除</p>
<p>编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换</p>
<p>编译条件：v-if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染</p>
<p>v-show 由false变为true的时候不会触发组件的生命周期</p>
<p>v-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由true变为false的时候触发组件的beforeDestory、destoryed方法</p>
<p>性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</p>
<h3 id="computed、-watch-区别"><a href="#computed、-watch-区别" class="headerlink" title="computed、 watch 区别"></a>computed、 watch 区别</h3><p>computed<br>1、computed是计算属性，也就是依赖某个值或者props通过计算得来得数据；<br>2、 computed的值是在getter执行之后进行缓存的，只有在它依赖的数据发生变化，会重新调用getter来计算；<br>3、 不支持异步，当computed内有异步操作时无效，无法监听数据的变化；</p>
<p>watch<br>1、watch是监听器，可以监听某一个数据，然后执行相应的操作；<br>2、不支持缓存，数据变直接会触发相应的操作；<br>3、监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；<br>4、支持异步操作；</p>
<h3 id="Vue-的生命周期"><a href="#Vue-的生命周期" class="headerlink" title="Vue 的生命周期"></a>Vue 的生命周期</h3><p>beforeCreate 在实例初始化之后，数据观测（data observe）和 event/watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问。</p>
<p>created 实例已经创建完成之后被调用。在这一步，实例已经完成以下的配置：数据观测（data observe ），属性和方法的运算，watch/event 事件回调。这里没有 $el，如果非要想与 DOM 进行交互，可以通过vm.$nextTick 来访问 DOM。</p>
<p>beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。</p>
<p>mounted 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom节点。</p>
<p>beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁 （patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</p>
<p>updated 发生在更新完成之后，当前阶段组件 Dom 已经完成更新。要注意的是避免在此期间更新数据，因为这个可能导致无限循环的更新，该钩子在服务器渲染期间不被调用。</p>
<p>beforeDestroy 实例销毁之前调用。在这一步，实力仍然完全可用。我们可以在这时进行 善后收尾工作，比如清除定时器。</p>
<p>destroy Vue实例销毁后调用。调用后，Vue实例指示的东西都会解绑定，所有的事件监听器会被移除，左右的子实例也会被销毁，该钩子在服务器端渲染不被调用。</p>
<p>activated keep-alive 专属，组件被激活时调用</p>
<p>deactivated keep-alive 专属，组件被销毁时调用</p>
<h3 id="父子组件生命周期顺序"><a href="#父子组件生命周期顺序" class="headerlink" title="父子组件生命周期顺序"></a>父子组件生命周期顺序</h3><p>加载渲染过程<br>父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted<br>子组件更新过程<br>父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated<br>父组件更新过程<br>父beforeUpdate -&gt; 父updated<br>销毁过程<br>父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed</p>
<h3 id="Vue-组件间通信方式"><a href="#Vue-组件间通信方式" class="headerlink" title="Vue 组件间通信方式"></a>Vue 组件间通信方式</h3><p>1、props 和 $emit。父组件向子组件传递数据是通过props传递的，子组件传递给父组件是通过$emit触发事件来做到的。</p>
<p>2、$parent 和 $children 获取单签组件的父组件和当前组件的子组件。</p>
<p>3、$attrs 和 $listeners A -&gt; B -&gt; C。Vue2.4开始提供了$attrs和$listeners来解决这个问题。</p>
<p>4、父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。（官方不推荐在实际业务中适用，但是写组件库时很常用。）</p>
<p>5、$refs 获取组件实例。</p>
<p>6、envetBus 兄弟组件数据传递，这种情况下可以使用事件总线的方式。</p>
<p>7、vuex 状态管理。</p>
<h3 id="Vue-的单项数据流"><a href="#Vue-的单项数据流" class="headerlink" title="Vue 的单项数据流"></a>Vue 的单项数据流</h3><p>数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父组件的状态，从而导致你的应用的数据流向难以理解</p>
<h3 id="keep-alive-组件"><a href="#keep-alive-组件" class="headerlink" title="keep-alive 组件"></a>keep-alive 组件</h3><p>keep-alive 是 Vue 内置的一个组件，可以实现组件缓存，当组件切换时不会对当前组件进行卸载</p>
<h3 id="slot-插槽"><a href="#slot-插槽" class="headerlink" title="slot 插槽"></a>slot 插槽</h3><p>vue里提供了一种将父组件的内容和子组件的模板整合的方法：内容分发，通过slot插槽来实现。</p>
<p>在组件标签内部写入的内容默认的会被替换掉，如果想要在组件的模板里使用这些内容，就在对应的位置写上slot标签，这个slot标签就代表着这些内容</p>
<h3 id="Vue-检测数组或对象的变化"><a href="#Vue-检测数组或对象的变化" class="headerlink" title="Vue 检测数组或对象的变化"></a>Vue 检测数组或对象的变化</h3><p>对象是用defineProperty setter。<br>数组考虑性能原因没有用 defineProperty 对数组的每一项进行拦截，而是选择对7种数组（push,shift,pop,splice,unshift,sort,reverse）方法进行重写（AOP 切片思想）。</p>
<p>所以在 Vue 中修改数组的索引和长度无法监控到。需要通过以上7种变异方法修改数组才会触发数组对应的watcher进行更新</p>
<h3 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h3><p>由于在浏览器中操作DOM是很昂贵的。频繁操作DOM，会产生一定性能问题。这就是虚拟Dom的产生原因。Vue2的Virtual DOM 借鉴了开源库 snabbdom 的实现。Virtual DOM本质就是用一个原生的JS对象去描述一个DOM节点，是对真实DOM的一层抽象。<br>优点：<br>1、保证性能下限：框架的虚拟DOM需要适配任何上层API可能产生的操作，他的一些DOM操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的DOM操作性能要好很多，因此框架的虚拟DOM至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，既保证性能的下限。<br>2、无需手动操作DOM：我们不需手动去操作DOM，只需要写好 View-Model的 代码逻辑，框架会根据虚拟DOM和数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率。<br>3、跨平台：虚拟DOM本质上是JavaScript对象，而DOM与平台强相关，相比之下虚拟DOM可以进行更方便地跨平台操作，例如服务器端渲染、weex开发等等。<br>缺点：<br>1、无法进行极致优化：虽然虚拟DOM + 合理的优化，足以应对大部分应用的性能需要，但在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化。<br>2、首次渲染大量DOM时，由于多了一层DOM计算，会比innerHTML插入慢。</p>
<h3 id="Vue-中-key-的作用"><a href="#Vue-中-key-的作用" class="headerlink" title="Vue 中 key 的作用"></a>Vue 中 key 的作用</h3><p>如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。key 是为Vue中Vnode的唯一标识，通过这个key，我们的diff操作可以更准确、更快速。<br>更准确：因为带key就不是就地复用了，在sameNode函数 a.key === b.key 对比中可以避免就地复用的情况。所以更加准确。<br>更快速：利用key的唯一性生成map对象来获取对应节点，比遍历方式块。</p>
<h3 id="nextTick-的原理"><a href="#nextTick-的原理" class="headerlink" title="nextTick 的原理"></a>nextTick 的原理</h3><p>nextTick 中的回调是在下次 DOM 更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。主要思路就是采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法</p>
<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>vuex 是专门为 vue 提供的全局状态管理系统，用于多个组件中数据共享、数据缓存</p>
<p>主要包括以下几个模块：</p>
<p>State:定义了应用状态的数据结构，可以在这里设置默认的初始化状态。<br>Getter:允许组件从Store中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。<br>Mutation:是唯一更改 store 中状态的方法，且必须是同步函数。<br>Action:用于提交 mutation，而不是直接变更状态，可以包含任意异步请求。<br>Module:允许将单一的 Store 拆分更多个 store 且同时保存在单一的状态树中。</p>
<h3 id="vue-router-的两种模式"><a href="#vue-router-的两种模式" class="headerlink" title="vue-router 的两种模式"></a>vue-router 的两种模式</h3><p>hash 模式<br>1、location.has 的值实际就是 URL 中 # 后面的东西。它的特点在于：hash虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。</p>
<p>2、可以为 hash 的改变添加监听事件<br>window.addEventListener(“hashchange”,funcRef,false)<br>每一次改变 hash (window.location.hash)，都会在浏览器的访问历史中增加一个记录，利用hash的以上特点，就可以实现前端路由“更新视图但不重新请求页面”的功能了<br>特点：兼容性好但是不美观</p>
<p>history 模式<br>利用 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。</p>
<p>这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础上，他们提供了对历史记录进行修改的功能。这两个方法有个共同点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页面应用前端路由“更新视图但不重新请求页面”提供了基础</p>
<p>特点：虽然美观，但是刷新会出现 404 需要后端进行配置</p>
<h3 id="vue-router-有几种导航钩子"><a href="#vue-router-有几种导航钩子" class="headerlink" title="vue-router 有几种导航钩子"></a>vue-router 有几种导航钩子</h3><p>路由钩子的执行流程，钩子函数种类有：全局守卫、路由守卫、组件守卫。<br>完整的导航解析流程：<br>1、导航被触发。<br>2、在失活的组件里调用 beforeRouterLeave 守卫。<br>3、调用全局的 beforeEach 守卫。<br>4、在重用的组件调用 beforeRouterUpdate 守卫（2.2+）。<br>5、在路由配置里面 beforeEnter。<br>6、解析异步路由组件。<br>7、在被激活的组件里调用 beforeRouterEnter。<br>8、调用全局的 beforeResolve 守卫（2.5+）。<br>9、导航被确认。<br>10、调用全局的 afterEach 钩子。<br>11、触发 DOM 更新。<br>12、调用 beforeRouterEnter 守卫中传给next的回调函数，创建好的组件实例会作为回调函数的参数传入。</p>
]]></content>
      <tags>
        <tag>面试</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JS数组之reduce</title>
    <url>/2020/05/13/JS%E6%95%B0%E7%BB%84%E4%B9%8Breduce/</url>
    <content><![CDATA[<h4 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h4><p>JS 数组中的数组方法reduce经常用到，该方法对数组中的每个元素执行callback函数(升序执行)，将其结果汇总为单个返回值。<br><a id="more"></a></p>
<h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.reduce(callback(accumulator, currentValue, index, array), initialValue)</span><br></pre></td></tr></table></figure>
<h5 id="参数"><a href="#参数" class="headerlink" title="参数:"></a>参数:</h5><p><code>callback</code><br>执行数组中每个值 (如果没有提供 initialValue则第一个值除外)的函数，包含四个参数：<br>accumulator<br>累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（见于下方）。</p>
<p><code>currentValue</code><br>数组中正在处理的元素。<br><code>index </code>可选<br>数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则从索引1起始。<br><code>array</code>可选<br>调用reduce()的数组<br><code>initialValue</code>可选<br>作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。</p>
<p>回调函数第一次执行时，<code>accumulator</code> 和<code>currentValue</code>的取值有两种情况：如果调用reduce()时提供了<code>initialValue</code>，<code>accumulator</code>取值为<code>initialValue</code>，<code>currentValue</code>取数组中的第一个值；如果没有提供 <code>initialValue</code>，那么<code>accumulator</code>取数组中的第一个值，<code>currentValue</code>取数组中的第二个值。</p>
<p><strong><br>注意：如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。<br></strong></p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const  total = [ 0, 1, 2, 3 ].reduce(</span><br><span class="line">  ( acc, cur ) =&gt; acc + cur,</span><br><span class="line">  0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="将二维数组转化为一维"><a href="#将二维数组转化为一维" class="headerlink" title="将二维数组转化为一维"></a>将二维数组转化为一维</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var flattened = [[0, 1], [2, 3], [4, 5]].reduce(</span><br><span class="line"> ( acc, cur ) =&gt; acc.concat(cur),</span><br><span class="line"> []</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h5 id="计算数组中每个元素出现的次数"><a href="#计算数组中每个元素出现的次数" class="headerlink" title="计算数组中每个元素出现的次数"></a>计算数组中每个元素出现的次数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var names = [&apos;Alice&apos;, &apos;Bob&apos;, &apos;Tiff&apos;, &apos;Bruce&apos;, &apos;Alice&apos;];</span><br><span class="line"></span><br><span class="line">var countedNames = names.reduce(function (allNames, name) &#123; </span><br><span class="line">  if (name in allNames) &#123;</span><br><span class="line">    allNames[name]++;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    allNames[name] = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return allNames;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line">// countedNames is:</span><br><span class="line">// &#123; &apos;Alice&apos;: 2, &apos;Bob&apos;: 1, &apos;Tiff&apos;: 1, &apos;Bruce&apos;: 1 &#125;</span><br></pre></td></tr></table></figure>
<h5 id="按属性对object分类"><a href="#按属性对object分类" class="headerlink" title="按属性对object分类"></a>按属性对object分类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var people = [</span><br><span class="line">  &#123; name: &apos;Alice&apos;, age: 21 &#125;,</span><br><span class="line">  &#123; name: &apos;Max&apos;, age: 20 &#125;,</span><br><span class="line">  &#123; name: &apos;Jane&apos;, age: 20 &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function groupBy(objectArray, property) &#123;</span><br><span class="line">  return objectArray.reduce(function (acc, obj) &#123;</span><br><span class="line">    var key = obj[property];</span><br><span class="line">    if (!acc[key]) &#123;</span><br><span class="line">      acc[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    acc[key].push(obj);</span><br><span class="line">    return acc;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var groupedPeople = groupBy(people, &apos;age&apos;);</span><br><span class="line">// groupedPeople is:</span><br><span class="line">// &#123; </span><br><span class="line">//   20: [</span><br><span class="line">//     &#123; name: &apos;Max&apos;, age: 20 &#125;, </span><br><span class="line">//     &#123; name: &apos;Jane&apos;, age: 20 &#125;</span><br><span class="line">//   ], </span><br><span class="line">//   21: [&#123; name: &apos;Alice&apos;, age: 21 &#125;] </span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用扩展运算符和initialValue绑定包含在对象数组中的数组"><a href="#使用扩展运算符和initialValue绑定包含在对象数组中的数组" class="headerlink" title="使用扩展运算符和initialValue绑定包含在对象数组中的数组"></a>使用扩展运算符和initialValue绑定包含在对象数组中的数组</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// friends - 对象数组</span><br><span class="line">// where object field &quot;books&quot; - list of favorite books </span><br><span class="line">var friends = [&#123;</span><br><span class="line">  name: &apos;Anna&apos;,</span><br><span class="line">  books: [&apos;Bible&apos;, &apos;Harry Potter&apos;],</span><br><span class="line">  age: 21</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  name: &apos;Bob&apos;,</span><br><span class="line">  books: [&apos;War and peace&apos;, &apos;Romeo and Juliet&apos;],</span><br><span class="line">  age: 26</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  name: &apos;Alice&apos;,</span><br><span class="line">  books: [&apos;The Lord of the Rings&apos;, &apos;The Shining&apos;],</span><br><span class="line">  age: 18</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// allbooks - list which will contain all friends&apos; books +  </span><br><span class="line">// additional list contained in initialValue</span><br><span class="line">var allbooks = friends.reduce(function(prev, curr) &#123;</span><br><span class="line">  return [...prev, ...curr.books];</span><br><span class="line">&#125;, [&apos;Alphabet&apos;]);</span><br><span class="line"></span><br><span class="line">// allbooks = [</span><br><span class="line">//   &apos;Alphabet&apos;, &apos;Bible&apos;, &apos;Harry Potter&apos;, &apos;War and peace&apos;, </span><br><span class="line">//   &apos;Romeo and Juliet&apos;, &apos;The Lord of the Rings&apos;,</span><br><span class="line">//   &apos;The Shining&apos;</span><br><span class="line">// ]</span><br></pre></td></tr></table></figure>
<h5 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h5><p><strong><br>注意： 如果你正在使用一个可以兼容<code>Set </code>和<code> Array.from() </code>的环境， 你可以使用<code>let orderedArray = Array.from(new Set(myArray)); <code>来获得一个相同元素被移除的数组。<br></code></code></strong><br>方法一：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myArray = [&apos;a&apos;, &apos;b&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;e&apos;, &apos;e&apos;, &apos;c&apos;, &apos;d&apos;, &apos;d&apos;, &apos;d&apos;, &apos;d&apos;];</span><br><span class="line">var myOrderedArray = myArray.reduce(function (accumulator, currentValue) &#123;</span><br><span class="line">  if (accumulator.indexOf(currentValue) === -1) &#123;</span><br><span class="line">    accumulator.push(currentValue);</span><br><span class="line">  &#125;</span><br><span class="line">  return accumulator</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure></p>
<p>方法二：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1,2,1,2,3,5,4,5,3,4,4,4,4];</span><br><span class="line">let result = arr.sort().reduce((init, current) =&gt; &#123;</span><br><span class="line">    if(init.length === 0 || init[init.length-1] !== current) &#123;</span><br><span class="line">        init.push(current);</span><br><span class="line">    &#125;</span><br><span class="line">    return init;</span><br><span class="line">&#125;, []);</span><br><span class="line">console.log(result); //[1,2,3,4,5]</span><br></pre></td></tr></table></figure></p>
<h5 id="按顺序运行Promise"><a href="#按顺序运行Promise" class="headerlink" title="按顺序运行Promise"></a>按顺序运行Promise</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Runs promises from array of functions that can return promises</span><br><span class="line"> * in chained manner</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;array&#125; arr - promise arr</span><br><span class="line"> * @return &#123;Object&#125; promise object</span><br><span class="line"> */</span><br><span class="line">function runPromiseInSequence(arr, input) &#123;</span><br><span class="line">  return arr.reduce(</span><br><span class="line">    (promiseChain, currentFunction) =&gt; promiseChain.then(currentFunction),</span><br><span class="line">    Promise.resolve(input)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise function 1</span><br><span class="line">function p1(a) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(a * 5);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise function 2</span><br><span class="line">function p2(a) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(a * 2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// function 3  - will be wrapped in a resolved promise by .then()</span><br><span class="line">function f3(a) &#123;</span><br><span class="line"> return a * 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise function 4</span><br><span class="line">function p4(a) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(a * 4);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const promiseArr = [p1, p2, f3, p4];</span><br><span class="line">runPromiseInSequence(promiseArr, 10)</span><br><span class="line">  .then(console.log);   // 1200</span><br></pre></td></tr></table></figure>
<h5 id="功能型函数管道"><a href="#功能型函数管道" class="headerlink" title="功能型函数管道"></a>功能型函数管道</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Building-blocks to use for composition</span><br><span class="line">const double = x =&gt; x + x;</span><br><span class="line">const triple = x =&gt; 3 * x;</span><br><span class="line">const quadruple = x =&gt; 4 * x;</span><br><span class="line"></span><br><span class="line">// Function composition enabling pipe functionality</span><br><span class="line">const pipe = (...functions) =&gt; input =&gt; functions.reduce(</span><br><span class="line">    (acc, fn) =&gt; fn(acc),</span><br><span class="line">    input</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// Composed functions for multiplication of specific values</span><br><span class="line">const multiply6 = pipe(double, triple);</span><br><span class="line">const multiply9 = pipe(triple, triple);</span><br><span class="line">const multiply16 = pipe(quadruple, quadruple);</span><br><span class="line">const multiply24 = pipe(double, triple, quadruple);</span><br><span class="line"></span><br><span class="line">// Usage</span><br><span class="line">multiply6(6); // 36</span><br><span class="line">multiply9(9); // 81</span><br><span class="line">multiply16(16); // 256</span><br><span class="line">multiply24(10); // 240</span><br></pre></td></tr></table></figure>
<h5 id="使用-reduce实现map"><a href="#使用-reduce实现map" class="headerlink" title="使用 reduce实现map"></a>使用 reduce实现map</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!Array.prototype.mapUsingReduce) &#123;</span><br><span class="line">  Array.prototype.mapUsingReduce = function(callback, thisArg) &#123;</span><br><span class="line">    return this.reduce(function(mappedArray, currentValue, index, array) &#123;</span><br><span class="line">      mappedArray[index] = callback.call(thisArg, currentValue, index, array);</span><br><span class="line">      return mappedArray;</span><br><span class="line">    &#125;, []);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[1, 2, , 3].mapUsingReduce(</span><br><span class="line">  (currentValue, index, array) =&gt; currentValue + index + array.length</span><br><span class="line">); // [5, 7, , 10]</span><br></pre></td></tr></table></figure>
<p>总之，reduce 方法功能十分强大，以后在项目中多多使用吧。😁</p>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>reduce</tag>
      </tags>
  </entry>
  <entry>
    <title>JS类型判断</title>
    <url>/2020/04/14/JS%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<p>我们都知道 JS 是弱类型语言，跟java等强类型语言不同，我们只能在运行时才真正知道某个变量是属于哪一种类型，因为在此之前，你可能有意无意的改变了变量的类型，因为变量的值及其数据类型可在声明周期内改变，这也是bug的来源，相信很多小伙伴都深有体会😆。<br><a id="more"></a></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>我们都知道，JS 中变量分为两种类型。基本类型和引用类型。</p>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>基本类型包括<code>Undefined、Null、String、Number、Boolean、Symbol</code>。基本类型按值访问，所以我们可操作保存在变量中实际的值。</p>
<p>基本类型的值在内存中占据固定大小的空间，是被保存在栈内存中。从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本，这两个值完全独立地存放在栈内存中。</p>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>引用类型是对象类型，包括<code>Object、Array、Function、Data、Regexp、Error</code>。引用类型的值是保存在堆内存中的对象，JS不允许直接访问内存中的位置，也就是说不能直接访问操作对象的内存空间。</p>
<p>操作对象时，实际上是在操作对象的引用，所以说引用类型的值是按引用访问的。从而有<code>[1, 2] === [1, 2]</code>为<code>false</code>。</p>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>js类型</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode算法题之两数之和</title>
    <url>/2019/01/09/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E4%B9%8B%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br><a id="more"></a><br>示例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line"></span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure></p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>我的解答，简单暴力。。</p>
<h4 id="解答一"><a href="#解答一" class="headerlink" title="解答一"></a>解答一</h4><ul>
<li>时间复杂度：O(n^2)， 对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。因此时间复杂度为 O(n^2)。</li>
<li>空间复杂度：O(1)</li>
<li>执行时间 148ms<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var twoSum = function(nums, target) &#123;</span><br><span class="line">    let length = nums.length;</span><br><span class="line">    for(let i = 0; i &lt;length; i++)&#123;</span><br><span class="line">        for(let j = i+1; j &lt; length; j++)&#123;</span><br><span class="line">            if(nums[i] + nums[j] === target)&#123;</span><br><span class="line">                return [i,j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="解答二"><a href="#解答二" class="headerlink" title="解答二"></a>解答二</h4><p>用es6的Map , 遍历一次即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var twoSum = function(nums, target) &#123;</span><br><span class="line">    let targetMap = new Map()</span><br><span class="line">    for (let i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">      const key = target - nums[i]</span><br><span class="line">      if (targetMap.has(key)) &#123;</span><br><span class="line">        return [targetMap.get(key), i]</span><br><span class="line">      &#125;</span><br><span class="line">      targetMap.set(nums[i], i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>两数之和</tag>
      </tags>
  </entry>
  <entry>
    <title>defer async</title>
    <url>/2022/02/19/defer-async/</url>
    <content><![CDATA[<p>我们都知道，普通的<code>script</code>标签加载 <code>js</code>会阻塞页面解析，因此优化措施可以将script放到<code><script src="/live2d-widget-model-hibiki/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2d-widget-model-hibiki/","pluginJsPath":null,"pluginModelPath":"live2d-widget-model-hibiki/assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2d-widget-model-hibiki/live2d-widget-model-hibiki/assets/hibiki.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":true},"react":{"opacity":0.7}});</script></code>标签前面。但还有一种更好的做法是加<code>defer </code>和 <code>async</code>属性。这两个属性使得<code>script</code>都不会阻塞<code>DOM</code>的渲染<br><a id="more"></a></p>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>如果script标签设置了该属性，则浏览器会异步的下载该文件并且不会影响到后续DOM的渲染；<br>如果有多个设置了defer的script标签存在，则会按照顺序执行所有的script；<br>defer脚本会在文档渲染完毕后，DOMContentLoaded事件调用前执行。</p>
<p>应用场景: 如果你的脚本代码依赖于页面中的DOM元素（文档是否解析完毕），或者被其他脚本文件依赖。<br>例：<br>1.评论框<br>2.代码语法高亮<br>3.polyfill.js</p>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>async脚本会在加载完毕后执行。<br>sync的执行，并不会按着script在页面中的顺序来执行，而是谁先加载完谁执行。<br>async脚本的加载不计入DOMContentLoaded事件统计</p>
<p>应用场景: 如果你的脚本并不关心页面中的DOM元素（文档是否解析完毕），并且也不会产生其他脚本需要的数据。</p>
<p>例：<br>1.百度统计</p>
]]></content>
  </entry>
  <entry>
    <title>es6数组方法</title>
    <url>/2022/02/17/es6%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>es5数组方法用的比较多，比较熟了，es6比较少，这里总结一下。<br><a id="more"></a></p>
<h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h3><p>用于将类数组和可遍历的对象转换为真正的数组<br>类数组：就是类似数组的对象，本质上要有length属性，说到底，任何拥有length属性的对象，都可以通过Array.from()方法转换为数组。<br>可遍历的对象：ES6新增的数据结构set和map</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let myArray = &#123;&apos;0&apos;:&apos;a&apos;,&apos;1&apos;:&apos;b&apos;,&apos;2&apos;:&apos;c&apos;&#125;;</span><br><span class="line">let arr = Array.from(myArray);</span><br><span class="line">console.log(arr);   //[]由于没有length属性打印结果为一个空数组</span><br><span class="line"></span><br><span class="line">let myArray = &#123;&apos;0&apos;:&apos;a&apos;,&apos;1&apos;:&apos;b&apos;,&apos;2&apos;:&apos;c&apos;,length:3&#125;;</span><br><span class="line">let arr = Array.from(myArray);</span><br><span class="line">console.log(arr);  //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line"></span><br><span class="line">console.log(Array.from(&#123;length:2&#125;));  //[undefined, undefined]</span><br></pre></td></tr></table></figure>
<h3 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h3><p>填充一个数组，一般用于数组的初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</span><br><span class="line">console.log(arr.fill(1)); // [1, 1, 1]</span><br></pre></td></tr></table></figure>
<h3 id="keys"><a href="#keys" class="headerlink" title="keys()"></a>keys()</h3><p>keys()遍历出所有的索引值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123;</span><br><span class="line">    console.log(index);</span><br><span class="line">&#125;  //0  1</span><br></pre></td></tr></table></figure>
<h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h3><p>valueOf()遍历所有的值<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (let index of [&apos;a&apos;, &apos;b&apos;].valueOf()) &#123;</span><br><span class="line">    console.log(index);</span><br><span class="line">&#125;  //a  b</span><br></pre></td></tr></table></figure></p>
<h3 id="entries"><a href="#entries" class="headerlink" title="entries()"></a>entries()</h3><p>entries()遍历值和索引<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (let index of [&apos;a&apos;, &apos;b&apos;].entries()) &#123;</span><br><span class="line">    console.log(index);</span><br><span class="line">&#125;  //[0, &quot;a&quot;] [1, &quot;b&quot;]</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>github actions 前端部署服务器</title>
    <url>/2021/07/04/github-actions-%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>前端每次部署都要手动打包感觉好麻烦，浪费了大量时间不说还容易出错。所以就研究了一下github 的github actions。github自己推出的持续集成工具。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: Blog CI/CD</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - master  # 只在master上push触发部署</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build-production:</span><br><span class="line"></span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    strategy:</span><br><span class="line">      matrix:</span><br><span class="line">        node-version: [12.x] # 配置所需node版本</span><br><span class="line">    steps:  # 自动化步骤</span><br><span class="line">    - uses: actions/checkout@v2   # 第一步，检出仓库副本</span><br><span class="line"></span><br><span class="line">    - name: Use Node.js $&#123;&#123; matrix.node-version &#125;&#125; #规定node.js版本(可不配置)</span><br><span class="line">      uses: actions/setup-node@v1</span><br><span class="line">      with:</span><br><span class="line">        node-version: $&#123;&#123; matrix.node-version &#125;&#125;</span><br><span class="line"></span><br><span class="line">    - name: Install dependencies  # 第二步，安装依赖</span><br><span class="line">      run: npm install</span><br><span class="line"></span><br><span class="line">    - name: Build                 # 第三步，打包代码</span><br><span class="line">      run: npm run build --if-present</span><br><span class="line"></span><br><span class="line">    # Deploy</span><br><span class="line">    - name: Deploy</span><br><span class="line">      uses: easingthemes/ssh-deploy@v2.0.7</span><br><span class="line">      env:</span><br><span class="line">        SSH_PRIVATE_KEY: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125; # 服务端私钥</span><br><span class="line">        ARGS: &quot;-avz --delete&quot;</span><br><span class="line">        SOURCE: &quot;dist/&quot;</span><br><span class="line">        REMOTE_HOST: $&#123;&#123; secrets.SSH_HOST &#125;&#125;</span><br><span class="line">        REMOTE_USER: $&#123;&#123; secrets.SSH_USERNAME &#125;&#125;</span><br><span class="line">        TARGET: $&#123;&#123; secrets.TARGET &#125;&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>CI</tag>
        <tag>部署</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title>http和https</title>
    <url>/2022/02/24/http%E5%92%8Chttps/</url>
    <content><![CDATA[<p>HTTP（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。<br><a id="more"></a><br>HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 http:// 打头的都是标准 HTTP 服务。</p>
<p>HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p>
<p>HTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p>
<p>HTTP 与 HTTPS 区别:</p>
<p>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</p>
<p>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</p>
<p>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</p>
<p>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</p>
<p>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</p>
<p>TCP 三次握手:</p>
<p>第一次握手：客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认<br>第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态<br>第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</p>
<pre><code>UDP                                    TCP
</code></pre><p>是否连接    无连接                                 面向连接<br>是否可靠    不可靠传输，不使用流量控制和拥塞控制        可靠传输，使用流量控制和拥塞控制<br>连接对象个数    支持一对一，一对多，多对一和多对多交互通信    只能是一对一通信<br>传输方式    面向报文    面向字节流<br>首部开销    首部开销小，仅8字节    首部最小20字节，最大60字节<br>适用场景    适用于实时应用（IP电话、视频会议、直播等）    适用于要求可靠传输的应用，例如文件传输</p>
]]></content>
      <tags>
        <tag>http</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>js 单引号替换成双引号,双引号替换成单引号</title>
    <url>/2021/03/25/js-%E5%8D%95%E5%BC%95%E5%8F%B7%E6%9B%BF%E6%8D%A2%E6%88%90%E5%8F%8C%E5%BC%95%E5%8F%B7-%E5%8F%8C%E5%BC%95%E5%8F%B7%E6%9B%BF%E6%8D%A2%E6%88%90%E5%8D%95%E5%BC%95%E5%8F%B7/</url>
    <content><![CDATA[<p>js方法传参<code>data</code>中有双引号时，会报错。比如以下代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;&lt;a href=&quot;#&quot; style=&quot;text-decoration: none;color: #7b7de5;margin-left: 10px&quot; onclick=&quot;handleAcClick(&apos;+data+&apos;)&quot;&gt;回执信息&lt;/a&gt;&apos;</span><br></pre></td></tr></table></figure></p>
<p>可以把参数中的双引号转换为单引号：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JSON.stringify(data).replace(/\&quot;/g,&quot;&apos;&quot;)</span><br></pre></td></tr></table></figure></p>
<p>最后使用参数的时候再把单引号转换为双引号就行了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JSON.parse(data.replace(/&apos;/g, &apos;&quot;&apos;))</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>jsonp原理与实现</title>
    <url>/2022/02/23/jsonp%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>jsonp是一种跨域通信的手段，它的原理其实很简单：</p>
<p>首先是利用script标签的src属性来实现跨域。</p>
<p>通过将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。</p>
<p>由于使用script标签的src属性，因此只支持get方法</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function jsonp(req)&#123;</span><br><span class="line">    var script = document.createElement(&apos;script&apos;);</span><br><span class="line">    var url = req.url + &apos;?callback=&apos; + req.callback.name;</span><br><span class="line">    script.src = url;</span><br><span class="line">    document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hello(res)&#123;</span><br><span class="line">    alert(&apos;hello &apos; + res.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jsonp(&#123;</span><br><span class="line">    url : &apos;&apos;,</span><br><span class="line">    callback : hello </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>服务器端代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var urllib = require(&apos;url&apos;);</span><br><span class="line"></span><br><span class="line">var port = 8080;</span><br><span class="line">var data = &#123;&apos;data&apos;:&apos;world&apos;&#125;;</span><br><span class="line"></span><br><span class="line">http.createServer(function(req,res)&#123;</span><br><span class="line">    var params = urllib.parse(req.url,true);</span><br><span class="line">    if(params.query.callback)&#123;</span><br><span class="line">        console.log(params.query.callback);</span><br><span class="line">        //jsonp</span><br><span class="line">        var str = params.query.callback + &apos;(&apos; + JSON.stringify(data) + &apos;)&apos;;</span><br><span class="line">        res.end(str);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;).listen(port,function()&#123;</span><br><span class="line">    console.log(&apos;jsonp server is on&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JSONP</tag>
      </tags>
  </entry>
  <entry>
    <title>js面试题</title>
    <url>/2022/02/21/js%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="js的数据类型"><a href="#js的数据类型" class="headerlink" title="js的数据类型"></a>js的数据类型</h3><p>js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。</p>
<p>基本数据类型：Undefined、Null、Boolean、Number、String</p>
<p>复杂数据类型指的是 Object 类型，所有其他的如 Array、Date 等数据类型都可以理解为 Object 类型的子类。<br><a id="more"></a><br>两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中<br>保存对应的指针来获取堆中的值。</p>
<h3 id="判断变量的类型"><a href="#判断变量的类型" class="headerlink" title="判断变量的类型"></a>判断变量的类型</h3><p>Object.prototype.toString.call([]） // ‘[object Array]’</p>
<h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><p>在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对<br>象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部<br>将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们<br>是不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto</strong> 属性来让我们访问这个属性，但是我们最好不要使用这<br>个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对<br>象的原型。</p>
<p>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又<br>会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就<br>是我们新建的对象为什么能够使用 toString() 等方法的原因。</p>
<h3 id="闭包及优缺点"><a href="#闭包及优缺点" class="headerlink" title="闭包及优缺点"></a>闭包及优缺点</h3><p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以<br>访问到当前函数的局部变量。</p>
<p>闭包有两个常用的用途。</p>
<p>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外<br>部访问到函数内部的变量，可以使用这种方法来创建私有变量。</p>
<p>函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以<br>这个变量对象不会被回收。</p>
<p>闭包的缺点是可能造成内存泄露</p>
<h3 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call apply bind"></a>call apply bind</h3><p>这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变</p>
<h3 id="DOM-事件流-和事件委托"><a href="#DOM-事件流-和事件委托" class="headerlink" title="DOM 事件流 和事件委托"></a>DOM 事件流 和事件委托</h3><p>事件捕获，事件冒泡。</p>
<p>事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到<br>目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。</p>
<p>使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。</p>
<h3 id="cookie-localStorage-sessionStorage"><a href="#cookie-localStorage-sessionStorage" class="headerlink" title="cookie localStorage sessionStorage"></a>cookie localStorage sessionStorage</h3><p>1）相同点是都是保存在浏览器端、且同源的<br>2）cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下<br>3）存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大<br>4）数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭<br>5）作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的</p>
<h3 id="数组和对象的常用方法"><a href="#数组和对象的常用方法" class="headerlink" title="数组和对象的常用方法"></a>数组和对象的常用方法</h3><p>数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</p>
<p>数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</p>
<p>数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</p>
<p>数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</p>
<p>数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</p>
<p>数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</p>
<p>数组归并方法 reduce() 和 reduceRight() 方法</p>
<h3 id="new-内部做了什么"><a href="#new-内部做了什么" class="headerlink" title="new 内部做了什么"></a>new 内部做了什么</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// （1）首先创建了一个新的空对象</span><br><span class="line">// （2）设置原型，将对象的原型设置为函数的 prototype 对象。</span><br><span class="line">// （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</span><br><span class="line">// （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</span><br><span class="line"></span><br><span class="line">// 实现:</span><br><span class="line"></span><br><span class="line">function objectFactory() &#123;</span><br><span class="line">  let newObject = null,</span><br><span class="line">    constructor = Array.prototype.shift.call(arguments),</span><br><span class="line">    result = null;</span><br><span class="line"></span><br><span class="line">  // 参数判断</span><br><span class="line">  if (typeof constructor !== &quot;function&quot;) &#123;</span><br><span class="line">    console.error(&quot;type error&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br><span class="line">  newObject = Object.create(constructor.prototype);</span><br><span class="line"></span><br><span class="line">  // 将 this 指向新建对象，并执行函数</span><br><span class="line">  result = constructor.apply(newObject, arguments);</span><br><span class="line"></span><br><span class="line">  // 判断返回对象</span><br><span class="line">  let flag =</span><br><span class="line">    result &amp;&amp; (typeof result === &quot;object&quot; || typeof result === &quot;function&quot;);</span><br><span class="line"></span><br><span class="line">  // 判断返回结果</span><br><span class="line">  return flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用方法</span><br><span class="line">// objectFactory(构造函数, 初始化参数);</span><br></pre></td></tr></table></figure>
<h3 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。</span><br><span class="line"></span><br><span class="line">// 函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</span><br><span class="line"></span><br><span class="line">// 函数防抖的实现</span><br><span class="line">function debounce(fn, wait) &#123;</span><br><span class="line">  var timer = null;</span><br><span class="line"></span><br><span class="line">  return function() &#123;</span><br><span class="line">    var context = this,</span><br><span class="line">      args = arguments;</span><br><span class="line"></span><br><span class="line">    // 如果此时存在定时器的话，则取消之前的定时器重新记时</span><br><span class="line">    if (timer) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置定时器，使事件间隔指定事件后执行</span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数节流的实现;</span><br><span class="line">function throttle(fn, delay) &#123;</span><br><span class="line">  var preTime = Date.now();</span><br><span class="line"></span><br><span class="line">  return function() &#123;</span><br><span class="line">    var context = this,</span><br><span class="line">      args = arguments,</span><br><span class="line">      nowTime = Date.now();</span><br><span class="line"></span><br><span class="line">    // 如果两次时间间隔超过了指定时间，则执行函数。</span><br><span class="line">    if (nowTime - preTime &gt;= delay) &#123;</span><br><span class="line">      preTime = Date.now();</span><br><span class="line">      return fn.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h3><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模<br>式来判断。</p>
<p>1.第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</p>
<p>2.第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</p>
<p>3.第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</p>
<p>4.第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和<br>函数。</p>
<h3 id="继承的几种实现方式"><a href="#继承的几种实现方式" class="headerlink" title="继承的几种实现方式"></a>继承的几种实现方式</h3><p>1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</p>
<p>（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</p>
<p>（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</p>
<p>（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</p>
<p>（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。</p>
<p>（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</p>
<p>寄生式组合继承:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = function() &#123;</span><br><span class="line">  console.log(&quot;My name is &quot; + this.name + &quot;.&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Student(name, grade) &#123;</span><br><span class="line">  Person.call(this, name);</span><br><span class="line">  this.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = Object.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line">Student.prototype.sayMyGrade = function() &#123;</span><br><span class="line">  console.log(&quot;My grade is &quot; + this.grade + &quot;.&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>不能当构造函数， this 是定义时上下文的this，不能改变</p>
<h3 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h3><p>我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。</p>
<p>创建一个 ajax 有这样几个步骤</p>
<p>首先是创建一个 XMLHttpRequest 对象。</p>
<p>然后在这个对象上使用 open 方法创建一个 http 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</p>
<p>在发起请求前，我们可以为这个对象添加一些信息和监听函数。比如说我们可以通过 setRequestHeader 方法来为请求添加头信息。我们还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，我们可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候我们可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候我们就可以通过 response 中的数据来对页面进行更新了。</p>
<p>当对象的属性和监听函数设置完成后，最后我们调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。</p>
<h3 id="var-let-const"><a href="#var-let-const" class="headerlink" title="var let const"></a>var let const</h3><p>1.const let 是块级作用域 var没有块级作用域,var只有函数和全局作用域<br>2.const let 不存在变量声明的提前，var有声明的提前，所以const和let在声明变量/常量 之前，是没办法获取到的，称为暂时性死区temporal dead zone<br>3.const let是ES6提出的，var是ES5<br>4.const 声明的是常量，常量不能被修改，let和var声明的是变量，可以被修改<br>5.const在声明时必须赋值，而let和var不需要<br>6.let 和const不能重复声明同一个值:如 let a=1 ; let a =2 这样是不被允许的，但var可以，最后一个var声明的值会覆盖之前的 如：var b =1 ;var b =2 console.log(b)  结果为2</p>
<h3 id="js-执行机制"><a href="#js-执行机制" class="headerlink" title="js 执行机制"></a>js 执行机制</h3><p>因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</p>
<p>微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</p>
<p>宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲<br>染等。</p>
<h3 id="异步编程-promise"><a href="#异步编程-promise" class="headerlink" title="异步编程 promise"></a>异步编程 promise</h3><h3 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h3><p>setTimeout和setInterval的问题是，它们都不精确。它们的内在运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行。</p>
<p>requestAnimationFrame采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，改善视觉效果。</p>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>BFC即 Block Formatting Contexts (块级格式化上下文).</p>
<p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p>
<p>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p>
<p>只要元素满足下面任一条件即可触发 BFC 特性：</p>
<p>body 根元素<br>浮动元素：float 除 none 以外的值<br>绝对定位元素：position (absolute、fixed)<br>display 为 inline-block、table-cells、flex<br>overflow 除了 visible 以外的值 (hidden、auto、scroll)</p>
<h3 id="for-of-和-for-in-的区别"><a href="#for-of-和-for-in-的区别" class="headerlink" title="for of 和 for in 的区别"></a>for of 和 for in 的区别</h3><p>for-in是为遍历对象而设计的，不适用于遍历数组。(遍历数组的缺点：数组的下标index值是数字，for-in遍历的index值”0”,”1”,”2”等是字符串)</p>
<p>for-in循环存在缺陷：循环会遍历对象自身的和继承的可枚举属性(不含Symbol属性)</p>
<p>for-of遍历</p>
<p>for-of这个方法避开了for-in循环的所有缺陷<br>与forEach()不同的是，它可以正确响应break、continue和return语句<br>for-of循环不仅支持数组，还支持大多数类数组对象，例如DOM NodeList对象。for-of循环也支持字符串遍历</p>
<p>for-of循环不支持普通对象，但如果你想迭代一个对象的属性，你可以用for-in循环（这也是它的本职工作）或内建的Object.keys()方法</p>
<h3 id="什么是重绘和回流"><a href="#什么是重绘和回流" class="headerlink" title="什么是重绘和回流"></a>什么是重绘和回流</h3><p>重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background<br>       -color，我们将这样的操作称为重绘。</p>
<p> 回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样<br>      的操作我们称为回流。</p>
<p> 常见引起回流属性和方法：</p>
<p> 任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</p>
<p> （1）添加或者删除可见的 DOM 元素；<br> （2）元素尺寸改变——边距、填充、边框、宽度和高度<br> （3）内容变化，比如用户在 input 框中输入文字<br> （4）浏览器窗口尺寸改变——resize事件发生时<br> （5）计算 offsetWidth 和 offsetHeight 属性<br> （6）设置 style 属性的值<br> （7）当你修改网页的默认字体时。</p>
<p> 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列<br> 回流。</p>
<p> 如何减少回流:</p>
<p> 1）使用 transform 替代 top</p>
<p> （2）不要把节点的属性值放在一个循环里当成循环里的变量</p>
<p> （3）不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</p>
<p> （4）把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM</p>
<p> （5）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。</p>
<h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>box-sizing属性可以指定盒子模型种类，content-box指定盒子模型为W3C（标准盒模型），border-box为IE盒子模型（怪异盒模型）。</p>
<p>box-sizing: content-box;//宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。</p>
<p>box-sizing: border-box;// 为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。</p>
]]></content>
      <tags>
        <tag>面试</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>promise面试题</title>
    <url>/2022/02/24/promise%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>promise 考察的比较多，这里记录一下，加深理解。</p>
<a id="more"></a>
<ol>
<li>ajax 的promise封装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getJSON(url) &#123;</span><br><span class="line">  // 创建一个 promise 对象</span><br><span class="line">  let promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    // 新建一个 http 请求</span><br><span class="line">    xhr.open(&quot;GET&quot;, url, true);</span><br><span class="line"></span><br><span class="line">    // 设置状态的监听函数</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">      if (this.readyState !== 4) return;</span><br><span class="line"></span><br><span class="line">      // 当请求成功或失败时，改变 promise 的状态</span><br><span class="line">      if (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 设置错误监听函数</span><br><span class="line">    xhr.onerror = function() &#123;</span><br><span class="line">      reject(new Error(this.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 设置响应的数据类型</span><br><span class="line">    xhr.responseType = &quot;json&quot;;</span><br><span class="line"></span><br><span class="line">    // 设置请求头信息</span><br><span class="line">    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line"></span><br><span class="line">    // 发送 http 请求</span><br><span class="line">    xhr.send(null);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>rails单元测试github actions</title>
    <url>/2021/07/08/rails%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95github-actions/</url>
    <content><![CDATA[<p>学 rails 时用到了单元测试，那就用 github actions 来跑测试吧。</p>
<p>下面是workflow配置：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: Ruby</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches: [ master ]</span><br><span class="line">  pull_request:</span><br><span class="line">    branches: [ master ]</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  test:</span><br><span class="line"></span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line"></span><br><span class="line">    services:</span><br><span class="line">      mysql:</span><br><span class="line">        image: mysql:5.7</span><br><span class="line">        env:</span><br><span class="line">          MYSQL_ROOT_PASSWORD: root</span><br><span class="line">          MYSQL_DATABASE: app_db_test</span><br><span class="line">        ports:</span><br><span class="line">          - 3306</span><br><span class="line">        options: &gt;-</span><br><span class="line">          --health-cmd=&quot;mysqladmin ping&quot;</span><br><span class="line">          --health-interval=10s</span><br><span class="line">          --health-timeout=5s</span><br><span class="line">          --health-retries=3</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">      - uses: actions/checkout@v1</span><br><span class="line"></span><br><span class="line">      - name: Set up Ruby 2.6.6</span><br><span class="line">        uses: ruby/setup-ruby@v1</span><br><span class="line">        with:</span><br><span class="line">          ruby-version: 2.6.6</span><br><span class="line"></span><br><span class="line">      - name: Gem cache</span><br><span class="line">        uses: actions/cache@v1</span><br><span class="line">        with:</span><br><span class="line">          path: vendor/bundle</span><br><span class="line">          key: $&#123;&#123; runner.os &#125;&#125;-gems-$&#123;&#123; hashFiles(&apos;**/Gemfile.lock&apos;) &#125;&#125;</span><br><span class="line">          restore-keys: |</span><br><span class="line">            $&#123;&#123; runner.os &#125;&#125;-gems-</span><br><span class="line"></span><br><span class="line">      - name: Verify MySQL connection from host</span><br><span class="line">        run: |</span><br><span class="line">          sudo apt-get install -y mysql-client libmysqlclient-dev</span><br><span class="line">          sudo /etc/init.d/mysql start</span><br><span class="line">          mysql -h 127.0.0.1 --port $&#123;&#123; job.services.mysql.ports[3306] &#125;&#125; -u root -proot -e &quot;CREATE DATABASE IF NOT EXISTS app_db_test;&quot;</span><br><span class="line"></span><br><span class="line">      - name: Bundle install, setup DB and run tests</span><br><span class="line">        env:</span><br><span class="line">          RAILS_ENV: test</span><br><span class="line">          DB_PASSWORD: root</span><br><span class="line">          DB_PORT: $&#123;&#123; job.services.mysql.ports[3306] &#125;&#125;</span><br><span class="line">        run: |</span><br><span class="line">          cp config/database.yml.ci config/database.yml</span><br><span class="line">          gem install bundler</span><br><span class="line">          bundle config path vendor/bundle</span><br><span class="line">          bundle install --jobs 4 --retry 3</span><br><span class="line">          bundle exec rails db:setup</span><br><span class="line">          bundle exec rails test</span><br></pre></td></tr></table></figure></p>
<p>database.yml.ci 配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default: &amp;default</span><br><span class="line">  adapter: mysql2</span><br><span class="line">  encoding: utf8mb4</span><br><span class="line">  pool: &lt;%= ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) &#123; 5 &#125; %&gt;</span><br><span class="line">  username: root</span><br><span class="line">  password: root</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  &lt;&lt;: *default</span><br><span class="line">  database: app_db_test</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>持续集成</tag>
        <tag>github actions</tag>
      </tags>
  </entry>
  <entry>
    <title>vps一键搭建ss脚本</title>
    <url>/2019/07/27/vps%E4%B8%80%E9%94%AE%E6%90%AD%E5%BB%BAss%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h3 id="安装脚本"><a href="#安装脚本" class="headerlink" title="安装脚本"></a>安装脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate http://down.whsir.com/downloads/shadowsocks-go.sh</span><br><span class="line">chmod +x shadowsocks-go.sh</span><br><span class="line">./shadowsocks-go.sh 2&gt;&amp;1 | tee shadowsocks-go.log</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="卸载方法"><a href="#卸载方法" class="headerlink" title="卸载方法"></a>卸载方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./shadowsocks-go.sh uninstall</span><br></pre></td></tr></table></figure>
<h3 id="用户密码配置"><a href="#用户密码配置" class="headerlink" title="用户密码配置"></a>用户密码配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/shadowsocks/config.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,  //你的主机IP</span><br><span class="line">    &quot;server_port&quot;:xxxx,  //端口</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;password&quot;:&quot;xxxx&quot;,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class="line">    &quot;timeout&quot;:600</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/init.d/shadowsocks restart</span><br></pre></td></tr></table></figure>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动：/etc/init.d/shadowsocks start</span><br><span class="line">停止：/etc/init.d/shadowsocks stop</span><br><span class="line">重启：/etc/init.d/shadowsocks restart</span><br><span class="line">状态：/etc/init.d/shadowsocks status</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>vps</tag>
        <tag>ss</tag>
      </tags>
  </entry>
  <entry>
    <title>事件捕获,冒泡,代理</title>
    <url>/2022/01/26/%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7-%E5%86%92%E6%B3%A1-%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>事件冒泡： 事件默认是由下往上的冒泡执行方式。以点击事件为例，当我们点击子元素也能触发父元素及以上元素的点击事件。事件执行顺序由下至上，这就是冒泡事件</p>
<p>事件捕获：执行方式是由上往下的捕获方式。还是以点击事件为例，当一个子元素绑定了点击事件，我们点击子元素时，父元素及以上的元素绑定的点击事件也会执行。事件的执行顺序时由上至下，这就是捕获事件</p>
<a id="more"></a>
<p>事件代理： 事件代理是基于事件冒泡，当我们点击子元素也能触发父元素及以上元素的点击事件，所以可以通过给父元素添加事件函数，通过判断当前点击的是不是子元素来添加一些处理。 这样我么就不用给每一个子元素添加事件，对于动态添加的子元素也适用。</p>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>事件捕获</tag>
        <tag>事件冒泡</tag>
      </tags>
  </entry>
  <entry>
    <title>从输入url到页面展现</title>
    <url>/2022/02/17/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0/</url>
    <content><![CDATA[<p>从输入url到页面展现, 背后的流程大致如下：<br>1.浏览器查找当前URL是否存在缓存，并比较缓存是否过期<br>2.DNS解析<br>3.通过IP向服务器发起TCP连接<br>4.向服务器发起HTTP请求<br>5.服务器返回请求内容<br>6.浏览器解析渲染页面<br>7.关闭连接<br><a id="more"></a></p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为强缓存，协商缓存</p>
<h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>强缓存判断HTTP首部字段：cache-control，Expires。</p>
<p>Expires是一个绝对时间，即服务器时间。浏览器检查当前时间，如果还没到失效时间就直接使用缓存文件。但是该方法存在一个问题：服务器时间与客户端时间可能不一致。因此该字段已经很少使用。</p>
<p>cache-control中的max-age保存一个相对时间。例如Cache-Control: max-age = 484200，表示浏览器收到文件后，缓存在484200s内均有效。 如果同时存在cache-control和Expires，浏览器总是优先使用cache-control。</p>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>协商缓存通过HTTP的last-modified，Etag字段进行判断。</p>
<p>last-modified是第一次请求资源时，服务器返回的字段，表示最后一次更新的时间。下一次浏览器请求资源时就发送if-modified-since字段。服务器用本地Last-modified时间与if-modified-since时间比较，如果不一致则认为缓存已过期并返回新资源给浏览器；如果时间一致则发送304状态码，让浏览器继续使用缓存。</p>
<p>Etag：资源的实体标识（哈希字符串），当资源内容更新时，Etag会改变。服务器会判断Etag是否发生变化(IfNoneMatch)，如果变化则返回新资源，否则返回304。</p>
<h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>我们知道在地址栏输入的域名并不是最后资源所在的真实位置，域名只是与IP地址的一个映射。网络服务器的IP地址那么多，我们不可能去记一串串的数字，因此域名就产生了，域名解析的过程实际是将域名还原为IP地址的过程。</p>
<p>首先浏览器先检查本地hosts文件是否有这个网址映射关系，如果有就调用这个IP地址映射，完成域名解析。</p>
<p>如果没找到则会查找本地DNS解析器缓存，如果查找到则返回。</p>
<p>如果还是没有找到则会查找本地DNS服务器，如果查找到则返回。</p>
<p>最后迭代查询，按根域服务器 -&gt;顶级域,.cn-&gt;第二层域，hb.cn -&gt;子域，<a href="http://www.hb.cn的顺序找到IP地址。" target="_blank" rel="noopener">www.hb.cn的顺序找到IP地址。</a></p>
<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>在通过第一步的DNS域名解析后，获取到了服务器的IP地址，在获取到IP地址后，便会开始建立一次连接，这是由TCP协议完成的，主要通过三次握手进行连接。</p>
<p>第一次握手： 建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认； </p>
<p>第二次握手： 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手： 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
<p> 完成三次握手，客户端与服务器开始传送数据。</p>
<h3 id="发起HTTP请求"><a href="#发起HTTP请求" class="headerlink" title="发起HTTP请求"></a>发起HTTP请求</h3><p> 完整的HTTP请求包含请求起始行、请求头部、请求主体三部分。</p>
<h3 id="服务器返回请求内容"><a href="#服务器返回请求内容" class="headerlink" title="服务器返回请求内容"></a>服务器返回请求内容</h3><p> 服务器在收到浏览器发送的HTTP请求之后，会将收到的HTTP报文封装成HTTP的Request对象，并通过不同的Web服务器进行处理，处理完的结果以HTTP的Response对象返回，主要包括状态码，响应头，响应报文三个部分。</p>
<p>　　状态码主要包括以下部分</p>
<p>　　1xx：指示信息–表示请求已接收，继续处理。</p>
<p>　　2xx：成功–表示请求已被成功接收、理解、接受。</p>
<p>　　3xx：重定向–要完成请求必须进行更进一步的操作。</p>
<p>　　4xx：客户端错误–请求有语法错误或请求无法实现。</p>
<p>　　5xx：服务器端错误–服务器未能实现合法的请求。</p>
<p>　　响应头主要由Cache-Control、 Connection、Date、Pragma等组成。</p>
<p>　　响应体为服务器返回给浏览器的信息，主要由HTML，css，js，图片文件组成。</p>
<h3 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h3><p>浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：</p>
<p>  解析HTML，构建DOM树<br>  解析CSS，生成CSS规则树<br>  合并DOM树和CSS规则树，生成render树<br>  布局render树（layout/reflow），负责各元素尺寸、位置的计算<br>  绘制render树（paint），绘制页面像素信息<br>  浏览器会将各层的信息发送给GUI，GUI会将各层合成（composite），显示在屏幕上</p>
<p>  遇到CSS样式资源（特点）：</p>
<pre><code>CSS下载时异步，不会阻塞浏览器构建DOM树，但是会阻塞渲染，也就是在构建render树时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）。有例外，media query声明的CSS是不会阻塞渲染的。
</code></pre><p>遇到JS脚本资源（特点）：</p>
<pre><code>阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析html；
浏览器的优化，在脚本阻塞时，也会继续下载其他资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已。defer（延迟执行）与async（异步执行），普通的脚本是会阻塞浏览器解析的，但是可以加上defer和async属性，这样脚本就变成异步了，可以等到解析完成后再执行。
</code></pre><p>遇到img图片类资源：</p>
<p>遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方。</p>
<p>　　如果说响应的内容是HTML文档的话，就需要浏览器进行解析渲染呈现给用户。整个过程涉及两个方面：解析和渲染。在渲染页面之前，需要构建DOM树和CSSOM树。</p>
<p>　　在浏览器还没接收到完整的 HTML 文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送 HTTP 请求重复上述的步骤。在收到 CSS 文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。这里就涉及了两个重要概念：Reflow和Repaint。</p>
<p>　　Reflow，也称作Layout，中文叫回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为Reflow。</p>
<p>　　Repaint，中文重绘，意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就OK了，这个过程称为Repaint。</p>
<p>　　所以说Reflow的成本比Repaint的成本高得多的多。DOM树里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。</p>
<p>　　下面这些动作有很大可能会是成本比较高的：</p>
<p>增加、删除、修改DOM结点时，会导致Reflow或Repaint</p>
<p>移动DOM的位置，或是搞个动画的时候</p>
<p>内容发生变化</p>
<p>修改CSS样式的时候</p>
<p>Resize窗口的时候（移动端没有这个问题），或是滚动的时候</p>
<p>修改网页的默认字体时</p>
<p>　　基本上来说，reflow有如下的几个原因：</p>
<p>Initial，网页初始化的时候</p>
<p>Incremental，一些js在操作DOM树时</p>
<p>Resize，其些元件的尺寸变了</p>
<p>StyleChange，如果CSS的属性发生变化了</p>
<p>Dirty，几个Incremental的reflow发生在同一个frame的子树上</p>
<h3 id="关闭TCP连接或继续保持连接"><a href="#关闭TCP连接或继续保持连接" class="headerlink" title="关闭TCP连接或继续保持连接"></a>关闭TCP连接或继续保持连接</h3><p>通过四次挥手关闭连接(FIN ACK, ACK, FIN ACK, ACK)。</p>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>优化打包体积</title>
    <url>/2022/01/24/%E4%BC%98%E5%8C%96%E6%89%93%E5%8C%85%E4%BD%93%E7%A7%AF/</url>
    <content><![CDATA[<p>最近发现项目打包体积竟然有20M了， 想了想项目确实有几张图片体积很大，还引入了echarts， 但不至于体积这么大吧，于是开始研究webpack打包了。<br><a id="more"></a><br>首先安装<code></code>webpack-bundle-analyzer` 插件， 找出最占用空间的文件有哪些。</p>
<p><code>npm install webpack-bundle-analyzer -D</code></p>
<p>我是用的<code>vue-cli4</code>， 所以在<code>vue.config.js</code>里面添加如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const BundleAnalyzerPlugin = require(&quot;webpack-bundle-analyzer&quot;).BundleAnalyzerPlugin;</span><br><span class="line"> </span><br><span class="line">// 展示图形化信息</span><br><span class="line">chainWebpack: config =&gt; &#123;</span><br><span class="line">  config</span><br><span class="line">    .plugin(&apos;webpack-bundle-analyzer&apos;)</span><br><span class="line">    .use(BundleAnalyzerPlugin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在<code>package.json</code>里面添加<code>&quot;analyzer&quot;: &quot;use_analyzer=true npm run serve&quot;</code><br>可以看到如下图：</p>
<p><img src="https://static01.imgkr.com/temp/8589678b5bcd43cc9107f90eb60f701e.jpg" alt="&#39;打包分析&#39;"></p>
<p>可以看到，echarts 可以说是罪魁祸首了，源码加上地图json文件，占用了很大一部分空间。elementUI的文件也很大。</p>
<p>首先是elementUI 的按需加载：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    &apos;@vue/app&apos;</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      &quot;component&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        libraryName: &quot;element-ui&quot;,</span><br><span class="line">        styleLibraryName: &quot;theme-chalk&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着优化echarts按需加载：<br><code>npm install babel-plugin-equire -D</code></p>
<figure class="highlight plain"><figcaption><span>echarts </span></figcaption><table><tr><td class="code"><pre><span class="line">  // 写上你需要的 echarts api</span><br><span class="line">  &quot;bar&quot;,</span><br><span class="line">  &quot;line&quot;,</span><br><span class="line">  &quot;map&quot;</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">export default echarts;</span><br></pre></td></tr></table></figure>
<p>在<code>vue.config.js</code>里面添加<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    &apos;@vue/app&apos;</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      &quot;component&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        libraryName: &quot;element-ui&quot;,</span><br><span class="line">        styleLibraryName: &quot;theme-chalk&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;equire&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>页面应用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 直接引用</span><br><span class="line"> import echarts from &apos;@/lib/util/echarts.js&apos; </span><br><span class="line"> </span><br><span class="line"> this.myChart = echarts.init(this.$refs.chart)</span><br></pre></td></tr></table></figure></p>
<p>删除无用的插件，避免加载多余的资源<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chainWebpack: config =&gt; &#123;</span><br><span class="line">    // 移除prefetch插件，避免加载多余的资源</span><br><span class="line">    config.plugins.delete(&apos;prefetch&apos;)</span><br><span class="line">    / 移除 preload 插件，避免加载多余的资源</span><br><span class="line">    config.plugins.delete(&apos;preload&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>图片按需加载:  <code>npm install image-webpack-loader -D</code><br><code>vue.config.js</code>里面：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config.module.rule(&apos;images&apos;)</span><br><span class="line">    .test(/\.(png|jpe?g|gif|webp)(\?.*)?$/)</span><br><span class="line">    .use(&apos;image-webpack-loader&apos;)</span><br><span class="line">    .loader(&apos;image-webpack-loader&apos;)</span><br><span class="line">    .options(&#123;</span><br><span class="line">      bypassOnDebug: true</span><br><span class="line">    &#125;)</span><br><span class="line">    .end()</span><br></pre></td></tr></table></figure></p>
<p>抽离 css 支持按需加载: <code>npm install mini-css-extract-plugin -D</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chainWebpack: config =&gt; &#123;</span><br><span class="line">  let miniCssExtractPlugin = new MiniCssExtractPlugin(&#123;</span><br><span class="line">    filename: &apos;assets/[name].[hash:8].css&apos;,</span><br><span class="line">    chunkFilename: &apos;assets/[name].[hash:8].css&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">  config.plugin(&apos;extract-css&apos;).use(miniCssExtractPlugin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>gzip压缩代码: <code>npm install compression-webpack-plugin -D</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">// 开启gzip压缩</span><br><span class="line">  config.plugins.push(</span><br><span class="line">    new CompressionWebpackPlugin(</span><br><span class="line">      &#123;</span><br><span class="line">        filename: info =&gt; &#123;</span><br><span class="line">          return `$&#123;info.path&#125;.gz$&#123;info.query&#125;`</span><br><span class="line">        &#125;,</span><br><span class="line">        algorithm: &apos;gzip&apos;,</span><br><span class="line">        threshold: 10240, // 只有大小大于该值的资源会被处理 10240</span><br><span class="line">        test: new RegExp(&apos;\\.(&apos; + [&apos;js&apos;].join(&apos;|&apos;) + &apos;)$&apos;</span><br><span class="line">        ),</span><br><span class="line">        minRatio: 0.8, // 只有压缩率小于这个值的资源才会被处理</span><br><span class="line">        deleteOriginalAssets: false // 删除原文件</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>webpack</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title>前端下载 excel</title>
    <url>/2021/07/02/%E5%89%8D%E7%AB%AF%E4%B8%8B%E8%BD%BD-excel/</url>
    <content><![CDATA[<p>前端导出excel:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import XLSX from &apos;xlsx&apos;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 导出Excel的处理函数--针对table</span><br><span class="line"> * @param &#123;Array&#125; headers: [&#123;key: &apos;date&apos;, title: &apos;日期&apos;&#125;, &#123;key: &apos;name&apos;, title: &apos;名称&apos;&#125;]</span><br><span class="line"> * @param &#123;Array&#125; data   : [&#123;date: &apos;2019-05-31&apos;, name: &apos;megen.huang&apos;&#125;, &#123;date: &apos;name&apos;, name: &apos;小明&apos;&#125;]</span><br><span class="line"> * @param &#123;String&#125; fileName: &apos;导出结果.xlsx&apos;</span><br><span class="line"> * */</span><br><span class="line">export default function Export2Excel (headers, data, fileName = &apos;导出结果.xlsx&apos;) &#123;</span><br><span class="line">  const _headers = headers.map((item, i) =&gt; Object.assign(&#123;&#125;, &#123; key: item.key, title: item.title, position: String.fromCharCode(65 + i) + 1 &#125;)).reduce((prev, next) =&gt; Object.assign(&#123;&#125;, prev, &#123; [next.position]: &#123; key: next.key, v: next.title &#125; &#125;), &#123;&#125;)</span><br><span class="line"></span><br><span class="line">  const _data = data.map((item, i) =&gt; headers.map((key, j) =&gt; Object.assign(&#123;&#125;, &#123; content: item[key.key], position: String.fromCharCode(65 + j) + (i + 2) &#125;)))</span><br><span class="line">  // 对刚才的结果进行降维处理（二维数组变成一维数组）</span><br><span class="line">    .reduce((prev, next) =&gt; prev.concat(next))</span><br><span class="line">    // 转换成 worksheet 需要的结构</span><br><span class="line">    .reduce((prev, next) =&gt; Object.assign(&#123;&#125;, prev, &#123; [next.position]: &#123; v: next.content &#125; &#125;), &#123;&#125;)</span><br><span class="line"></span><br><span class="line">  // 合并 headers 和 data</span><br><span class="line">  const output = Object.assign(&#123;&#125;, _headers, _data)</span><br><span class="line">  // 获取所有单元格的位置</span><br><span class="line">  const outputPos = Object.keys(output)</span><br><span class="line">  // 计算出范围 ,[&quot;A1&quot;,..., &quot;H2&quot;]</span><br><span class="line">  const ref = `$&#123;outputPos[0]&#125;:$&#123;outputPos[outputPos.length - 1]&#125;`</span><br><span class="line">  // 构建 workbook 对象</span><br><span class="line">  const wb = &#123;</span><br><span class="line">    SheetNames: [&apos;mySheet&apos;],</span><br><span class="line">    Sheets: &#123;</span><br><span class="line">      mySheet: Object.assign(</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">        output,</span><br><span class="line">        &#123;</span><br><span class="line">          &apos;!ref&apos;: ref,</span><br><span class="line">          // eslint-disable-next-line</span><br><span class="line">            &apos;!cols&apos;: headers.map(item =&gt; (&#123;wpx: 100&#125;))</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 导出 Excel</span><br><span class="line">  XLSX.writeFile(wb, fileName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>加油!</title>
    <url>/2022/02/12/%E5%8A%A0%E6%B2%B9/</url>
    <content><![CDATA[<p>最近面试不太顺利，再一次感叹平时真的没有好好准备，遇到好的工作机会最后只能感叹，机会是留给有准备的人的。<br>不过，不要气馁，加油吧！好好总结，接着干！！！</p>
<p>很久没有写日记了，感觉可以经常写写，记录平时的一些感想，多年后再看应该很有趣吧😁</p>
]]></content>
  </entry>
  <entry>
    <title>多条件判断的另一种写法</title>
    <url>/2020/02/23/%E5%A4%9A%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<p>在写业务逻辑到时候，我们经常会碰到写很多if, 少数还好，多个的话可能会用switch, 随着业务逻辑越来越复杂，代码可能越来越臃肿，这个时候我们需要另一种写法简化代码。<br><a id="more"></a></p>
<h3 id="ES6-Map"><a href="#ES6-Map" class="headerlink" title="ES6 Map"></a>ES6 Map</h3><p>从阮一峰老师的基础教程里可以知道 Map 的大致用法： </p>
<p>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const m = new Map();</span><br><span class="line">const o = &#123;p: &apos;Hello World&apos;&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, &apos;content&apos;)</span><br><span class="line">m.get(o) // &quot;content&quot;</span><br><span class="line"></span><br><span class="line">m.has(o) // true</span><br><span class="line">m.delete(o) // true</span><br><span class="line">m.has(o) // false</span><br></pre></td></tr></table></figure>
<p>上面代码使用 Map 结构的set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。</p>
<p>上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">  [&apos;name&apos;, &apos;张三&apos;],</span><br><span class="line">  [&apos;title&apos;, &apos;Author&apos;]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size // 2</span><br><span class="line">map.has(&apos;name&apos;) // true</span><br><span class="line">map.get(&apos;name&apos;) // &quot;张三&quot;</span><br><span class="line">map.has(&apos;title&apos;) // true</span><br><span class="line">map.get(&apos;title&apos;) // &quot;Author&quot;</span><br></pre></td></tr></table></figure>
<p>利用以上这一点，我们就可以重构多个 if 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//将判断条件作为对象的属性名，将处理逻辑作为对象的属性值</span><br><span class="line">var Statistics = function()&#123;</span><br><span class="line">  console.log(&apos;执行&apos;)</span><br><span class="line">&#125;</span><br><span class="line">const comparativeTotles = new Map([</span><br><span class="line">    [0,Statistics],</span><br><span class="line">    [1,Statistics],</span><br><span class="line">    [2,Statistics],</span><br><span class="line">    [3,Statistics]</span><br><span class="line"> ])</span><br><span class="line">let map = function(val)&#123;</span><br><span class="line">      return comparativeTotles.get(val)</span><br><span class="line">&#125; </span><br><span class="line">let getMap  = map(1); //如果查找不到返回undefined</span><br><span class="line">if(!getMap)&#123;</span><br><span class="line">      console.log(&apos;查找不到&apos;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    concaozuole.log(&apos;执行操作&apos;)</span><br><span class="line">      getMap()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>根据子节点寻找父节点路径</title>
    <url>/2020/05/03/%E6%A0%B9%E6%8D%AE%E5%AD%90%E8%8A%82%E7%82%B9%E5%AF%BB%E6%89%BE%E7%88%B6%E8%8A%82%E7%82%B9%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>最近项目遇到一个需求，在一个树结构里，根据子节点寻找父节点的路径，这里记录一下。<br><a id="more"></a></p>
<h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getParent(array, nodeCode)&#123;</span><br><span class="line">  let stack = [];</span><br><span class="line">  let going = true;</span><br><span class="line">  </span><br><span class="line">  let walker = (array, nodeCode) =&gt; &#123;</span><br><span class="line">      array.forEach(item =&gt; &#123;</span><br><span class="line">          if (!going) return;</span><br><span class="line">          stack.push(item[&apos;nodeCode&apos;]);</span><br><span class="line">          if (item[&apos;nodeCode&apos;] === nodeCode) &#123;</span><br><span class="line">              going = false;</span><br><span class="line">          &#125; else if (item[&apos;child&apos;]) &#123;</span><br><span class="line">              walker(item[&apos;child&apos;], nodeCode);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              stack.pop();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      if (going) stack.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  walker(array, nodeCode);</span><br><span class="line"></span><br><span class="line">  return stack.join(&apos;,&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getParent(data, target)&#123;</span><br><span class="line"></span><br><span class="line">  const get = (children, target, record = []) =&gt; (</span><br><span class="line">    children.reduce((result, &#123; nodeCode, child: innerChildren &#125;) =&gt; &#123;</span><br><span class="line">      if (nodeCode === target) &#123;</span><br><span class="line">        return [...record, target]</span><br><span class="line">      &#125;</span><br><span class="line">      if (innerChildren) &#123;</span><br><span class="line">        return [...result, ...get(innerChildren, target, [...record, nodeCode])]</span><br><span class="line">      &#125;</span><br><span class="line">      return result</span><br><span class="line">    &#125;, []))</span><br><span class="line"></span><br><span class="line">  return get(data, target).join(&apos;,&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>测试持续集成</title>
    <url>/2020/09/27/%E6%B5%8B%E8%AF%95%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<p>添加了travis的一个脚本，这样每次只要提交一下博客文件就行了，打包的工作就交还给travis了。持续集成真的很好用，极大地提升了效率。</p>
]]></content>
      <tags>
        <tag>持续集成</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝</title>
    <url>/2022/02/15/%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>JS实现深拷贝：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function deepCopy(obj)&#123;</span><br><span class="line">  let newObj = null</span><br><span class="line">  if(typeof obj === &apos;object&apos; &amp;&amp; obj)&#123;</span><br><span class="line">    for(let key in obj)&#123;</span><br><span class="line">      newObj = obj[key] instanceof Array ? [] : &#123;&#125;</span><br><span class="line">      newObj[key] = deepCopy(obj[key])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    newObj = obj</span><br><span class="line">  &#125;</span><br><span class="line">  return newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之数组(一)</title>
    <url>/2020/04/25/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84-%E4%B8%80/</url>
    <content><![CDATA[<p>给定一个数组，排序后实现第一大的值放在最左边，同时把第二大的值放在最右边，第三大的值放在左边第二位，第四大的值放在右边第二位，依次排序，比如给定<code>[1, 2, 3, 4]</code>，期望结果: <code>[4, 2, 1, 3]</code><br><a id="more"></a></p>
<h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><p>先把数组降序，然后索引为偶数的放左边，为奇数的放右边</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sortArr = (nums) =&gt; &#123;</span><br><span class="line">  let arr = nums.sort((x,y) =&gt; &#123;</span><br><span class="line">    return y - x</span><br><span class="line">  &#125;)</span><br><span class="line">  let a= []</span><br><span class="line">  let b = []</span><br><span class="line">  arr.forEach((element,i) =&gt; &#123;</span><br><span class="line">    if(i%2 === 0)&#123;</span><br><span class="line">      a.push(element)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      b.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return a.concat(b.reverse())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sortArr([2,1,4,100,50,13,8,6,23]))//[ 100, 23,  8,  4, 1, 2,  6, 13, 50 ]</span><br></pre></td></tr></table></figure>
<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>分别从数组的头和尾迭代数组，找出最大值，并与之交换位置，继续在剩下的数组里重复上一步做法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const getArrMaxIndex = (nums,start,end) =&gt; &#123;</span><br><span class="line">  const max = Math.max.apply(null, nums.slice(start,end))</span><br><span class="line">  return nums.findIndex(i=&gt;i===max)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">const sortArr = (nums) =&gt; &#123;</span><br><span class="line">  let [start, temp, end] = [0, 1, nums.length]</span><br><span class="line">  while(start !== end-1)&#123;</span><br><span class="line">    let maxIndex = getArrMaxIndex(nums,start,end)</span><br><span class="line">    if(temp%2 === 0)&#123;</span><br><span class="line">      [nums[end-1], nums[maxIndex]] = [nums[maxIndex], nums[end-1]]</span><br><span class="line">      end--</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      [nums[start], nums[maxIndex]] = [nums[maxIndex], nums[start]]</span><br><span class="line">      start++</span><br><span class="line">    &#125;</span><br><span class="line">    temp++</span><br><span class="line">  &#125;</span><br><span class="line">  return nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sortArr([2,1,4,100,50,13,8,6,23]))//[ 100, 23,  8,  4, 1, 2,  6, 13, 50 ]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>箭头函数this</title>
    <url>/2022/02/17/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this/</url>
    <content><![CDATA[<p>箭头函数的this在定义时就确定，就是箭头函数所在作用域的this, 且不会被call, apply, bind改变。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let foo = () =&gt; &#123;</span><br><span class="line">  console.log(this.id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let id = 21</span><br><span class="line"></span><br><span class="line">foo.call(&#123; id: 42 &#125;) //  21</span><br></pre></td></tr></table></figure></p>
<p>如果箭头函数改成function，则会被改变，因为function的this只有调用时能确定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let foo = function()&#123;</span><br><span class="line">  console.log(this.id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let id = 21</span><br><span class="line"></span><br><span class="line">foo.call(&#123; id: 42 &#125;) // 42</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>箭头函数</tag>
      </tags>
  </entry>
  <entry>
    <title>终于看完老友记了</title>
    <url>/2020/04/12/%E7%BB%88%E4%BA%8E%E7%9C%8B%E5%AE%8C%E8%80%81%E5%8F%8B%E8%AE%B0%E4%BA%86/</url>
    <content><![CDATA[<p><img src="https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1586704138&amp;di=4329bb6a517364a9577b7c3f3bae641e&amp;src=http://i2.hdslb.com/bfs/archive/5339b0aee51f6be61ff127d1a7f9e085ca893104.jpg" alt="&#39;老友记海报&#39;"></p>
<p>大学时就开始看老友记了，但是断断续续看了几季后又没看了，直到今天终于看完。看完发现，老友记真的好多荤段子啊😝，真的是少儿不宜2333。最开始我看海报，就是上面这张，我以为乔伊会和菲比在一起，最后看完竟然不是，哈哈哈哈。总之看完还是有点伤感的，有追完剧的空虚，也想起了大学时代那些日子，时间过得可真快啊。。。</p>
]]></content>
      <tags>
        <tag>老友记</tag>
        <tag>美剧</tag>
      </tags>
  </entry>
  <entry>
    <title>递归实现1-100求和</title>
    <url>/2022/02/12/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B01-100%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<p>面试遇到这样一道题，平时没怎么准备算法，当时就卡壳了。后来回来想想其实很简单。要做的其实就是，用递归实现每次加1或者减1。</p>
<p>真的要好好看看算法了呀。<br><a id="more"></a><br>减1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sum(n)&#123;</span><br><span class="line">  if(n === 1) return 1</span><br><span class="line">  return sum(n - 1) + n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(100) // 5050</span><br></pre></td></tr></table></figure>
<p>加1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sum(num, start) &#123;</span><br><span class="line">  num += start</span><br><span class="line">  start++;</span><br><span class="line">  if (start &gt; 100) &#123;</span><br><span class="line">    return num</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    sum(num, start)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">sum(0, 1) // 5050</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>锚点导航</title>
    <url>/2021/03/16/%E9%94%9A%E7%82%B9%E5%AF%BC%E8%88%AA/</url>
    <content><![CDATA[<p>导航锚点跟随页面滚动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;#work_info&quot;).on(&apos;scroll&apos;, function ()&#123;</span><br><span class="line">    var flag = 0;</span><br><span class="line">    var w_top = $(this).scrollTop();</span><br><span class="line">    var len = arr.length</span><br><span class="line">    for(var i=0;i&lt;len;i++)&#123;</span><br><span class="line">        var linkText = arr[i];</span><br><span class="line">            if(w_top &gt;= topObj[linkText] &amp;&amp; w_top &lt;= topObj[[arr[i+1]]])&#123;</span><br><span class="line">                flag = i</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (topObj[arr[flag+1]] - w_top &lt; w_top -  topObj[arr[flag]])&#123;</span><br><span class="line">        flag += 1</span><br><span class="line">    &#125;</span><br><span class="line">    if (w_top &gt; arr[len - 1]) &#123;</span><br><span class="line">        flag = len - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    $(&apos;.anchor-link[value=&apos;+arr[flag]+&apos;]&apos;).siblings().removeClass(&apos;anchor-active&apos;);</span><br><span class="line">    $(&apos;.anchor-link[value=&apos;+arr[flag]+&apos;]&apos;).addClass(&apos;anchor-active&apos;)                     </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖节流</title>
    <url>/2022/02/12/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p>在处理高频事件，类似于window的resize或者scorll，或者input输入校验等操作时。如果直接执行事件处理器，会增大浏览器的负担，严重的直接卡死，用户体验非常不好。</p>
<p>面对这种情况，我们一般可以采用防抖和节流的方式减少调用频率。<br><a id="more"></a><br>防抖：在单位时间内执行函数， 如果在这个时间内触发，则重新开始计时。<br>场景：滚动条滚动， 提交按钮</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debounce(fn, delay)&#123;</span><br><span class="line">  let timer</span><br><span class="line">  return function()&#123;</span><br><span class="line">    if(timer) clearTimeout(timer)</span><br><span class="line"></span><br><span class="line">    timer = setTimeout(fn, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>防抖：在单位时间内执行函数， 如果在这个时间内触发，则忽略，直到时间结束，函数开始执行<br>场景：输入框输入</p>
<p>第一种实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle(fn, delay)&#123;</span><br><span class="line">  let timer</span><br><span class="line">  return function()&#123;</span><br><span class="line">    if(timer) return</span><br><span class="line">    timer = setTimeout(function()&#123;</span><br><span class="line">      fn()</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle(fn, delay)&#123;</span><br><span class="line">  let prev = Date.now()</span><br><span class="line">  return function()&#123;</span><br><span class="line">    if(Date.now() - prev &lt; delay) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    fn()</span><br><span class="line">    prev = Date.now()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>防抖</tag>
        <tag>节流</tag>
      </tags>
  </entry>
</search>
