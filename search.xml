<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JS数组之reduce</title>
    <url>/2020/05/13/JS%E6%95%B0%E7%BB%84%E4%B9%8Breduce/</url>
    <content><![CDATA[<h4 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h4><p>JS 数组中的数组方法reduce经常用到，该方法对数组中的每个元素执行callback函数(升序执行)，将其结果汇总为单个返回值。<br><a id="more"></a></p>
<h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.reduce(callback(accumulator, currentValue, index, array), initialValue)</span><br></pre></td></tr></table></figure>
<h5 id="参数"><a href="#参数" class="headerlink" title="参数:"></a>参数:</h5><p><code>callback</code><br>执行数组中每个值 (如果没有提供 initialValue则第一个值除外)的函数，包含四个参数：<br>accumulator<br>累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（见于下方）。</p>
<p><code>currentValue</code><br>数组中正在处理的元素。<br><code>index </code>可选<br>数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则从索引1起始。<br><code>array</code>可选<br>调用reduce()的数组<br><code>initialValue</code>可选<br>作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。</p>
<p>回调函数第一次执行时，<code>accumulator</code> 和<code>currentValue</code>的取值有两种情况：如果调用reduce()时提供了<code>initialValue</code>，<code>accumulator</code>取值为<code>initialValue</code>，<code>currentValue</code>取数组中的第一个值；如果没有提供 <code>initialValue</code>，那么<code>accumulator</code>取数组中的第一个值，<code>currentValue</code>取数组中的第二个值。</p>
<p><strong><br>注意：如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。<br></strong></p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const  total = [ 0, 1, 2, 3 ].reduce(</span><br><span class="line">  ( acc, cur ) =&gt; acc + cur,</span><br><span class="line">  0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="将二维数组转化为一维"><a href="#将二维数组转化为一维" class="headerlink" title="将二维数组转化为一维"></a>将二维数组转化为一维</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var flattened = [[0, 1], [2, 3], [4, 5]].reduce(</span><br><span class="line"> ( acc, cur ) =&gt; acc.concat(cur),</span><br><span class="line"> []</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h5 id="计算数组中每个元素出现的次数"><a href="#计算数组中每个元素出现的次数" class="headerlink" title="计算数组中每个元素出现的次数"></a>计算数组中每个元素出现的次数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var names = [&apos;Alice&apos;, &apos;Bob&apos;, &apos;Tiff&apos;, &apos;Bruce&apos;, &apos;Alice&apos;];</span><br><span class="line"></span><br><span class="line">var countedNames = names.reduce(function (allNames, name) &#123; </span><br><span class="line">  if (name in allNames) &#123;</span><br><span class="line">    allNames[name]++;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    allNames[name] = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return allNames;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line">// countedNames is:</span><br><span class="line">// &#123; &apos;Alice&apos;: 2, &apos;Bob&apos;: 1, &apos;Tiff&apos;: 1, &apos;Bruce&apos;: 1 &#125;</span><br></pre></td></tr></table></figure>
<h5 id="按属性对object分类"><a href="#按属性对object分类" class="headerlink" title="按属性对object分类"></a>按属性对object分类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var people = [</span><br><span class="line">  &#123; name: &apos;Alice&apos;, age: 21 &#125;,</span><br><span class="line">  &#123; name: &apos;Max&apos;, age: 20 &#125;,</span><br><span class="line">  &#123; name: &apos;Jane&apos;, age: 20 &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function groupBy(objectArray, property) &#123;</span><br><span class="line">  return objectArray.reduce(function (acc, obj) &#123;</span><br><span class="line">    var key = obj[property];</span><br><span class="line">    if (!acc[key]) &#123;</span><br><span class="line">      acc[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    acc[key].push(obj);</span><br><span class="line">    return acc;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var groupedPeople = groupBy(people, &apos;age&apos;);</span><br><span class="line">// groupedPeople is:</span><br><span class="line">// &#123; </span><br><span class="line">//   20: [</span><br><span class="line">//     &#123; name: &apos;Max&apos;, age: 20 &#125;, </span><br><span class="line">//     &#123; name: &apos;Jane&apos;, age: 20 &#125;</span><br><span class="line">//   ], </span><br><span class="line">//   21: [&#123; name: &apos;Alice&apos;, age: 21 &#125;] </span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用扩展运算符和initialValue绑定包含在对象数组中的数组"><a href="#使用扩展运算符和initialValue绑定包含在对象数组中的数组" class="headerlink" title="使用扩展运算符和initialValue绑定包含在对象数组中的数组"></a>使用扩展运算符和initialValue绑定包含在对象数组中的数组</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// friends - 对象数组</span><br><span class="line">// where object field &quot;books&quot; - list of favorite books </span><br><span class="line">var friends = [&#123;</span><br><span class="line">  name: &apos;Anna&apos;,</span><br><span class="line">  books: [&apos;Bible&apos;, &apos;Harry Potter&apos;],</span><br><span class="line">  age: 21</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  name: &apos;Bob&apos;,</span><br><span class="line">  books: [&apos;War and peace&apos;, &apos;Romeo and Juliet&apos;],</span><br><span class="line">  age: 26</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  name: &apos;Alice&apos;,</span><br><span class="line">  books: [&apos;The Lord of the Rings&apos;, &apos;The Shining&apos;],</span><br><span class="line">  age: 18</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// allbooks - list which will contain all friends&apos; books +  </span><br><span class="line">// additional list contained in initialValue</span><br><span class="line">var allbooks = friends.reduce(function(prev, curr) &#123;</span><br><span class="line">  return [...prev, ...curr.books];</span><br><span class="line">&#125;, [&apos;Alphabet&apos;]);</span><br><span class="line"></span><br><span class="line">// allbooks = [</span><br><span class="line">//   &apos;Alphabet&apos;, &apos;Bible&apos;, &apos;Harry Potter&apos;, &apos;War and peace&apos;, </span><br><span class="line">//   &apos;Romeo and Juliet&apos;, &apos;The Lord of the Rings&apos;,</span><br><span class="line">//   &apos;The Shining&apos;</span><br><span class="line">// ]</span><br></pre></td></tr></table></figure>
<h5 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h5><p><strong><br>注意： 如果你正在使用一个可以兼容<code>Set </code>和<code> Array.from() </code>的环境， 你可以使用<code>let orderedArray = Array.from(new Set(myArray)); <code>来获得一个相同元素被移除的数组。<br></code></code></strong><br>方法一：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myArray = [&apos;a&apos;, &apos;b&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;e&apos;, &apos;e&apos;, &apos;c&apos;, &apos;d&apos;, &apos;d&apos;, &apos;d&apos;, &apos;d&apos;];</span><br><span class="line">var myOrderedArray = myArray.reduce(function (accumulator, currentValue) &#123;</span><br><span class="line">  if (accumulator.indexOf(currentValue) === -1) &#123;</span><br><span class="line">    accumulator.push(currentValue);</span><br><span class="line">  &#125;</span><br><span class="line">  return accumulator</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure></p>
<p>方法二：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1,2,1,2,3,5,4,5,3,4,4,4,4];</span><br><span class="line">let result = arr.sort().reduce((init, current) =&gt; &#123;</span><br><span class="line">    if(init.length === 0 || init[init.length-1] !== current) &#123;</span><br><span class="line">        init.push(current);</span><br><span class="line">    &#125;</span><br><span class="line">    return init;</span><br><span class="line">&#125;, []);</span><br><span class="line">console.log(result); //[1,2,3,4,5]</span><br></pre></td></tr></table></figure></p>
<h5 id="按顺序运行Promise"><a href="#按顺序运行Promise" class="headerlink" title="按顺序运行Promise"></a>按顺序运行Promise</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Runs promises from array of functions that can return promises</span><br><span class="line"> * in chained manner</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;array&#125; arr - promise arr</span><br><span class="line"> * @return &#123;Object&#125; promise object</span><br><span class="line"> */</span><br><span class="line">function runPromiseInSequence(arr, input) &#123;</span><br><span class="line">  return arr.reduce(</span><br><span class="line">    (promiseChain, currentFunction) =&gt; promiseChain.then(currentFunction),</span><br><span class="line">    Promise.resolve(input)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise function 1</span><br><span class="line">function p1(a) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(a * 5);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise function 2</span><br><span class="line">function p2(a) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(a * 2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// function 3  - will be wrapped in a resolved promise by .then()</span><br><span class="line">function f3(a) &#123;</span><br><span class="line"> return a * 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise function 4</span><br><span class="line">function p4(a) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(a * 4);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const promiseArr = [p1, p2, f3, p4];</span><br><span class="line">runPromiseInSequence(promiseArr, 10)</span><br><span class="line">  .then(console.log);   // 1200</span><br></pre></td></tr></table></figure>
<h5 id="功能型函数管道"><a href="#功能型函数管道" class="headerlink" title="功能型函数管道"></a>功能型函数管道</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Building-blocks to use for composition</span><br><span class="line">const double = x =&gt; x + x;</span><br><span class="line">const triple = x =&gt; 3 * x;</span><br><span class="line">const quadruple = x =&gt; 4 * x;</span><br><span class="line"></span><br><span class="line">// Function composition enabling pipe functionality</span><br><span class="line">const pipe = (...functions) =&gt; input =&gt; functions.reduce(</span><br><span class="line">    (acc, fn) =&gt; fn(acc),</span><br><span class="line">    input</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// Composed functions for multiplication of specific values</span><br><span class="line">const multiply6 = pipe(double, triple);</span><br><span class="line">const multiply9 = pipe(triple, triple);</span><br><span class="line">const multiply16 = pipe(quadruple, quadruple);</span><br><span class="line">const multiply24 = pipe(double, triple, quadruple);</span><br><span class="line"></span><br><span class="line">// Usage</span><br><span class="line">multiply6(6); // 36</span><br><span class="line">multiply9(9); // 81</span><br><span class="line">multiply16(16); // 256</span><br><span class="line">multiply24(10); // 240</span><br></pre></td></tr></table></figure>
<h5 id="使用-reduce实现map"><a href="#使用-reduce实现map" class="headerlink" title="使用 reduce实现map"></a>使用 reduce实现map</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!Array.prototype.mapUsingReduce) &#123;</span><br><span class="line">  Array.prototype.mapUsingReduce = function(callback, thisArg) &#123;</span><br><span class="line">    return this.reduce(function(mappedArray, currentValue, index, array) &#123;</span><br><span class="line">      mappedArray[index] = callback.call(thisArg, currentValue, index, array);</span><br><span class="line">      return mappedArray;</span><br><span class="line">    &#125;, []);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[1, 2, , 3].mapUsingReduce(</span><br><span class="line">  (currentValue, index, array) =&gt; currentValue + index + array.length</span><br><span class="line">); // [5, 7, , 10]</span><br></pre></td></tr></table></figure>
<p>总之，reduce 方法功能十分强大，以后在项目中多多使用吧。😁</p>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>reduce</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode算法题之两数之和</title>
    <url>/2019/01/09/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E4%B9%8B%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br><a id="more"></a><br>示例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line"></span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure></p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>我的解答，简单暴力。。</p>
<h4 id="解答一"><a href="#解答一" class="headerlink" title="解答一"></a>解答一</h4><ul>
<li>时间复杂度：O(n^2)， 对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。因此时间复杂度为 O(n^2)。</li>
<li>空间复杂度：O(1)</li>
<li>执行时间 148ms<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var twoSum = function(nums, target) &#123;</span><br><span class="line">    let length = nums.length;</span><br><span class="line">    for(let i = 0; i &lt;length; i++)&#123;</span><br><span class="line">        for(let j = i+1; j &lt; length; j++)&#123;</span><br><span class="line">            if(nums[i] + nums[j] === target)&#123;</span><br><span class="line">                return [i,j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="解答二"><a href="#解答二" class="headerlink" title="解答二"></a>解答二</h4><p>用es6的Map , 遍历一次即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var twoSum = function(nums, target) &#123;</span><br><span class="line">    let targetMap = new Map()</span><br><span class="line">    for (let i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">      const key = target - nums[i]</span><br><span class="line">      if (targetMap.has(key)) &#123;</span><br><span class="line">        return [targetMap.get(key), i]</span><br><span class="line">      &#125;</span><br><span class="line">      targetMap.set(nums[i], i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>两数之和</tag>
      </tags>
  </entry>
  <entry>
    <title>JS类型判断</title>
    <url>/2020/04/14/JS%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<p>我们都知道 JS 是弱类型语言，跟java等强类型语言不同，我们只能在运行时才真正知道某个变量是属于哪一种类型，因为在此之前，你可能有意无意的改变了变量的类型，因为变量的值及其数据类型可在声明周期内改变，这也是bug的来源，相信很多小伙伴都深有体会😆。<br><a id="more"></a></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>我们都知道，JS 中变量分为两种类型。基本类型和引用类型。</p>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>基本类型包括<code>Undefined、Null、String、Number、Boolean、Symbol</code>。基本类型按值访问，所以我们可操作保存在变量中实际的值。</p>
<p>基本类型的值在内存中占据固定大小的空间，是被保存在栈内存中。从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本，这两个值完全独立地存放在栈内存中。</p>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>引用类型是对象类型，包括<code>Object、Array、Function、Data、Regexp、Error</code>。引用类型的值是保存在堆内存中的对象，JS不允许直接访问内存中的位置，也就是说不能直接访问操作对象的内存空间。</p>
<p>操作对象时，实际上是在操作对象的引用，所以说引用类型的值是按引用访问的。从而有<code>[1, 2] === [1, 2]</code>为<code>false</code>。</p>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>js类型</tag>
      </tags>
  </entry>
  <entry>
    <title>vps一键搭建ss脚本</title>
    <url>/2019/07/27/vps%E4%B8%80%E9%94%AE%E6%90%AD%E5%BB%BAss%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h3 id="安装脚本"><a href="#安装脚本" class="headerlink" title="安装脚本"></a>安装脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate http://down.whsir.com/downloads/shadowsocks-go.sh</span><br><span class="line">chmod +x shadowsocks-go.sh</span><br><span class="line">./shadowsocks-go.sh 2&gt;&amp;1 | tee shadowsocks-go.log</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="卸载方法"><a href="#卸载方法" class="headerlink" title="卸载方法"></a>卸载方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./shadowsocks-go.sh uninstall</span><br></pre></td></tr></table></figure>
<h3 id="用户密码配置"><a href="#用户密码配置" class="headerlink" title="用户密码配置"></a>用户密码配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/shadowsocks/config.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,  //你的主机IP</span><br><span class="line">    &quot;server_port&quot;:xxxx,  //端口</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;password&quot;:&quot;xxxx&quot;,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class="line">    &quot;timeout&quot;:600</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/init.d/shadowsocks restart</span><br></pre></td></tr></table></figure>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动：/etc/init.d/shadowsocks start</span><br><span class="line">停止：/etc/init.d/shadowsocks stop</span><br><span class="line">重启：/etc/init.d/shadowsocks restart</span><br><span class="line">状态：/etc/init.d/shadowsocks status</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>vps</tag>
        <tag>ss</tag>
      </tags>
  </entry>
  <entry>
    <title>我买房了</title>
    <url>/2020/10/12/%E6%88%91%E4%B9%B0%E6%88%BF%E4%BA%86/</url>
    <content><![CDATA[<p>2020年10月7日，我买房了！！！！😁完成了人生中一件大事！房子位于武汉黄家湖，地铁口。房价15500一平带精装修，环境还不错。只不过每月的房贷可真是压力不小啊。接下来的日子要努力奋斗了！！美好的日子就在前方！！😝</p>
]]></content>
      <tags>
        <tag>生活</tag>
        <tag>买房</tag>
      </tags>
  </entry>
  <entry>
    <title>最近的心情</title>
    <url>/2020/09/27/%E6%9C%80%E8%BF%91%E7%9A%84%E7%83%A6%E6%81%BC/</url>
    <content><![CDATA[<p>今天是2020年9月27号，心情不是很好。</p>
<p>最近心真的好累，应该是人生中最累的一个月了。家里发生了一些事，工作上总是熬夜加班，各种烦恼。哎，感觉自己已在崩溃的边缘，好想休息一段时间。</p>
<p>还有家里介绍了一个女孩给我认识，可我只简单聊了几句就没下文了。该跟她说什么呢？跟异性聊天本来就不是我的特长，如果只是为了聊天而聊天，那只会更加尴尬吧。这也是最近的烦恼之一吧。</p>
]]></content>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>多条件判断的另一种写法</title>
    <url>/2020/02/23/%E5%A4%9A%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<p>在写业务逻辑到时候，我们经常会碰到写很多if, 少数还好，多个的话可能会用switch, 随着业务逻辑越来越复杂，代码可能越来越臃肿，这个时候我们需要另一种写法简化代码。<br><a id="more"></a></p>
<h3 id="ES6-Map"><a href="#ES6-Map" class="headerlink" title="ES6 Map"></a>ES6 Map</h3><p>从阮一峰老师的基础教程里可以知道 Map 的大致用法： </p>
<p>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const m = new Map();</span><br><span class="line">const o = &#123;p: &apos;Hello World&apos;&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, &apos;content&apos;)</span><br><span class="line">m.get(o) // &quot;content&quot;</span><br><span class="line"></span><br><span class="line">m.has(o) // true</span><br><span class="line">m.delete(o) // true</span><br><span class="line">m.has(o) // false</span><br></pre></td></tr></table></figure>
<p>上面代码使用 Map 结构的set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。</p>
<p>上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">  [&apos;name&apos;, &apos;张三&apos;],</span><br><span class="line">  [&apos;title&apos;, &apos;Author&apos;]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size // 2</span><br><span class="line">map.has(&apos;name&apos;) // true</span><br><span class="line">map.get(&apos;name&apos;) // &quot;张三&quot;</span><br><span class="line">map.has(&apos;title&apos;) // true</span><br><span class="line">map.get(&apos;title&apos;) // &quot;Author&quot;</span><br></pre></td></tr></table></figure>
<p>利用以上这一点，我们就可以重构多个 if 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//将判断条件作为对象的属性名，将处理逻辑作为对象的属性值</span><br><span class="line">var Statistics = function()&#123;</span><br><span class="line">  console.log(&apos;执行&apos;)</span><br><span class="line">&#125;</span><br><span class="line">const comparativeTotles = new Map([</span><br><span class="line">    [0,Statistics],</span><br><span class="line">    [1,Statistics],</span><br><span class="line">    [2,Statistics],</span><br><span class="line">    [3,Statistics]</span><br><span class="line"> ])</span><br><span class="line">let map = function(val)&#123;</span><br><span class="line">      return comparativeTotles.get(val)</span><br><span class="line">&#125; </span><br><span class="line">let getMap  = map(1); //如果查找不到返回undefined</span><br><span class="line">if(!getMap)&#123;</span><br><span class="line">      console.log(&apos;查找不到&apos;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    concaozuole.log(&apos;执行操作&apos;)</span><br><span class="line">      getMap()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>根据子节点寻找父节点路径</title>
    <url>/2020/05/03/%E6%A0%B9%E6%8D%AE%E5%AD%90%E8%8A%82%E7%82%B9%E5%AF%BB%E6%89%BE%E7%88%B6%E8%8A%82%E7%82%B9%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>最近项目遇到一个需求，在一个树结构里，根据子节点寻找父节点的路径，这里记录一下。<br><a id="more"></a></p>
<h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getParent(array, nodeCode)&#123;</span><br><span class="line">  let stack = [];</span><br><span class="line">  let going = true;</span><br><span class="line">  </span><br><span class="line">  let walker = (array, nodeCode) =&gt; &#123;</span><br><span class="line">      array.forEach(item =&gt; &#123;</span><br><span class="line">          if (!going) return;</span><br><span class="line">          stack.push(item[&apos;nodeCode&apos;]);</span><br><span class="line">          if (item[&apos;nodeCode&apos;] === nodeCode) &#123;</span><br><span class="line">              going = false;</span><br><span class="line">          &#125; else if (item[&apos;child&apos;]) &#123;</span><br><span class="line">              walker(item[&apos;child&apos;], nodeCode);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              stack.pop();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      if (going) stack.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  walker(array, nodeCode);</span><br><span class="line"></span><br><span class="line">  return stack.join(&apos;,&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getParent(data, target)&#123;</span><br><span class="line"></span><br><span class="line">  const get = (children, target, record = []) =&gt; (</span><br><span class="line">    children.reduce((result, &#123; nodeCode, child: innerChildren &#125;) =&gt; &#123;</span><br><span class="line">      if (nodeCode === target) &#123;</span><br><span class="line">        return [...record, target]</span><br><span class="line">      &#125;</span><br><span class="line">      if (innerChildren) &#123;</span><br><span class="line">        return [...result, ...get(innerChildren, target, [...record, nodeCode])]</span><br><span class="line">      &#125;</span><br><span class="line">      return result</span><br><span class="line">    &#125;, []))</span><br><span class="line"></span><br><span class="line">  return get(data, target).join(&apos;,&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之数组(一)</title>
    <url>/2020/04/25/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84-%E4%B8%80/</url>
    <content><![CDATA[<p>给定一个数组，排序后实现第一大的值放在最左边，同时把第二大的值放在最右边，第三大的值放在左边第二位，第四大的值放在右边第二位，依次排序，比如给定<code>[1, 2, 3, 4]</code>，期望结果: <code>[4, 2, 1, 3]</code><br><a id="more"></a></p>
<h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><p>先把数组降序，然后索引为偶数的放左边，为奇数的放右边</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sortArr = (nums) =&gt; &#123;</span><br><span class="line">  let arr = nums.sort((x,y) =&gt; &#123;</span><br><span class="line">    return y - x</span><br><span class="line">  &#125;)</span><br><span class="line">  let a= []</span><br><span class="line">  let b = []</span><br><span class="line">  arr.forEach((element,i) =&gt; &#123;</span><br><span class="line">    if(i%2 === 0)&#123;</span><br><span class="line">      a.push(element)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      b.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return a.concat(b.reverse())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sortArr([2,1,4,100,50,13,8,6,23]))//[ 100, 23,  8,  4, 1, 2,  6, 13, 50 ]</span><br></pre></td></tr></table></figure>
<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>分别从数组的头和尾迭代数组，找出最大值，并与之交换位置，继续在剩下的数组里重复上一步做法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const getArrMaxIndex = (nums,start,end) =&gt; &#123;</span><br><span class="line">  const max = Math.max.apply(null, nums.slice(start,end))</span><br><span class="line">  return nums.findIndex(i=&gt;i===max)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">const sortArr = (nums) =&gt; &#123;</span><br><span class="line">  let [start, temp, end] = [0, 1, nums.length]</span><br><span class="line">  while(start !== end-1)&#123;</span><br><span class="line">    let maxIndex = getArrMaxIndex(nums,start,end)</span><br><span class="line">    if(temp%2 === 0)&#123;</span><br><span class="line">      [nums[end-1], nums[maxIndex]] = [nums[maxIndex], nums[end-1]]</span><br><span class="line">      end--</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      [nums[start], nums[maxIndex]] = [nums[maxIndex], nums[start]]</span><br><span class="line">      start++</span><br><span class="line">    &#125;</span><br><span class="line">    temp++</span><br><span class="line">  &#125;</span><br><span class="line">  return nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sortArr([2,1,4,100,50,13,8,6,23]))//[ 100, 23,  8,  4, 1, 2,  6, 13, 50 ]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>测试持续集成</title>
    <url>/2020/09/27/%E6%B5%8B%E8%AF%95%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<p>添加了travis的一个脚本，这样每次只要提交一下博客文件就行了，打包的工作就交还给travis了。持续集成真的很好用，极大地提升了效率。</p>
]]></content>
      <tags>
        <tag>持续集成</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>锚点导航</title>
    <url>/2021/03/16/%E9%94%9A%E7%82%B9%E5%AF%BC%E8%88%AA/</url>
    <content><![CDATA[<p>导航锚点跟随页面滚动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;#work_info&quot;).on(&apos;scroll&apos;, function ()&#123;</span><br><span class="line">    var flag = 0;</span><br><span class="line">    var w_top = $(this).scrollTop();</span><br><span class="line">    var len = arr.length</span><br><span class="line">    for(var i=0;i&lt;len;i++)&#123;</span><br><span class="line">        var linkText = arr[i];</span><br><span class="line">            if(w_top &gt;= topObj[linkText] &amp;&amp; w_top &lt;= topObj[[arr[i+1]]])&#123;</span><br><span class="line">                flag = i</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (topObj[arr[flag+1]] - w_top &lt; w_top -  topObj[arr[flag]])&#123;</span><br><span class="line">        flag += 1</span><br><span class="line">    &#125;</span><br><span class="line">    if (w_top &gt; arr[len - 1]) &#123;</span><br><span class="line">        flag = len - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    $(&apos;.anchor-link[value=&apos;+arr[flag]+&apos;]&apos;).siblings().removeClass(&apos;anchor-active&apos;);</span><br><span class="line">    $(&apos;.anchor-link[value=&apos;+arr[flag]+&apos;]&apos;).addClass(&apos;anchor-active&apos;)                     </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>终于看完老友记了</title>
    <url>/2020/04/12/%E7%BB%88%E4%BA%8E%E7%9C%8B%E5%AE%8C%E8%80%81%E5%8F%8B%E8%AE%B0%E4%BA%86/</url>
    <content><![CDATA[<p><img src="https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1586704138&amp;di=4329bb6a517364a9577b7c3f3bae641e&amp;src=http://i2.hdslb.com/bfs/archive/5339b0aee51f6be61ff127d1a7f9e085ca893104.jpg" alt="&#39;老友记海报&#39;"></p>
<p>大学时就开始看老友记了，但是断断续续看了几季后又没看了，直到今天终于看完。看完发现，老友记真的好多荤段子啊😝，真的是少儿不宜2333。最开始我看海报，就是上面这张，我以为乔伊会和菲比在一起，最后看完竟然不是，哈哈哈哈。总之看完还是有点伤感的，有追完剧的空虚，也想起了大学时代那些日子，时间过得可真快啊。。。</p>
]]></content>
      <tags>
        <tag>老友记</tag>
        <tag>美剧</tag>
      </tags>
  </entry>
</search>
