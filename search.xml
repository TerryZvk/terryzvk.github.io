<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JS数组之reduce</title>
    <url>/2020/05/13/JS%E6%95%B0%E7%BB%84%E4%B9%8Breduce/</url>
    <content><![CDATA[<h4 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h4><p>JS 数组中的数组方法reduce经常用到，该方法对数组中的每个元素执行callback函数(升序执行)，将其结果汇总为单个返回值。<br><a id="more"></a></p>
<h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.reduce(callback(accumulator, currentValue, index, array), initialValue)</span><br></pre></td></tr></table></figure>
<h5 id="参数"><a href="#参数" class="headerlink" title="参数:"></a>参数:</h5><p><code>callback</code><br>执行数组中每个值 (如果没有提供 initialValue则第一个值除外)的函数，包含四个参数：<br>accumulator<br>累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（见于下方）。</p>
<p><code>currentValue</code><br>数组中正在处理的元素。<br><code>index </code>可选<br>数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则从索引1起始。<br><code>array</code>可选<br>调用reduce()的数组<br><code>initialValue</code>可选<br>作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。</p>
<p>回调函数第一次执行时，<code>accumulator</code> 和<code>currentValue</code>的取值有两种情况：如果调用reduce()时提供了<code>initialValue</code>，<code>accumulator</code>取值为<code>initialValue</code>，<code>currentValue</code>取数组中的第一个值；如果没有提供 <code>initialValue</code>，那么<code>accumulator</code>取数组中的第一个值，<code>currentValue</code>取数组中的第二个值。</p>
<p><strong><br>注意：如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。<br></strong></p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const  total = [ 0, 1, 2, 3 ].reduce(</span><br><span class="line">  ( acc, cur ) =&gt; acc + cur,</span><br><span class="line">  0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="将二维数组转化为一维"><a href="#将二维数组转化为一维" class="headerlink" title="将二维数组转化为一维"></a>将二维数组转化为一维</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var flattened = [[0, 1], [2, 3], [4, 5]].reduce(</span><br><span class="line"> ( acc, cur ) =&gt; acc.concat(cur),</span><br><span class="line"> []</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h5 id="计算数组中每个元素出现的次数"><a href="#计算数组中每个元素出现的次数" class="headerlink" title="计算数组中每个元素出现的次数"></a>计算数组中每个元素出现的次数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var names = [&apos;Alice&apos;, &apos;Bob&apos;, &apos;Tiff&apos;, &apos;Bruce&apos;, &apos;Alice&apos;];</span><br><span class="line"></span><br><span class="line">var countedNames = names.reduce(function (allNames, name) &#123; </span><br><span class="line">  if (name in allNames) &#123;</span><br><span class="line">    allNames[name]++;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    allNames[name] = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return allNames;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line">// countedNames is:</span><br><span class="line">// &#123; &apos;Alice&apos;: 2, &apos;Bob&apos;: 1, &apos;Tiff&apos;: 1, &apos;Bruce&apos;: 1 &#125;</span><br></pre></td></tr></table></figure>
<h5 id="按属性对object分类"><a href="#按属性对object分类" class="headerlink" title="按属性对object分类"></a>按属性对object分类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var people = [</span><br><span class="line">  &#123; name: &apos;Alice&apos;, age: 21 &#125;,</span><br><span class="line">  &#123; name: &apos;Max&apos;, age: 20 &#125;,</span><br><span class="line">  &#123; name: &apos;Jane&apos;, age: 20 &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function groupBy(objectArray, property) &#123;</span><br><span class="line">  return objectArray.reduce(function (acc, obj) &#123;</span><br><span class="line">    var key = obj[property];</span><br><span class="line">    if (!acc[key]) &#123;</span><br><span class="line">      acc[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    acc[key].push(obj);</span><br><span class="line">    return acc;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var groupedPeople = groupBy(people, &apos;age&apos;);</span><br><span class="line">// groupedPeople is:</span><br><span class="line">// &#123; </span><br><span class="line">//   20: [</span><br><span class="line">//     &#123; name: &apos;Max&apos;, age: 20 &#125;, </span><br><span class="line">//     &#123; name: &apos;Jane&apos;, age: 20 &#125;</span><br><span class="line">//   ], </span><br><span class="line">//   21: [&#123; name: &apos;Alice&apos;, age: 21 &#125;] </span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用扩展运算符和initialValue绑定包含在对象数组中的数组"><a href="#使用扩展运算符和initialValue绑定包含在对象数组中的数组" class="headerlink" title="使用扩展运算符和initialValue绑定包含在对象数组中的数组"></a>使用扩展运算符和initialValue绑定包含在对象数组中的数组</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// friends - 对象数组</span><br><span class="line">// where object field &quot;books&quot; - list of favorite books </span><br><span class="line">var friends = [&#123;</span><br><span class="line">  name: &apos;Anna&apos;,</span><br><span class="line">  books: [&apos;Bible&apos;, &apos;Harry Potter&apos;],</span><br><span class="line">  age: 21</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  name: &apos;Bob&apos;,</span><br><span class="line">  books: [&apos;War and peace&apos;, &apos;Romeo and Juliet&apos;],</span><br><span class="line">  age: 26</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  name: &apos;Alice&apos;,</span><br><span class="line">  books: [&apos;The Lord of the Rings&apos;, &apos;The Shining&apos;],</span><br><span class="line">  age: 18</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// allbooks - list which will contain all friends&apos; books +  </span><br><span class="line">// additional list contained in initialValue</span><br><span class="line">var allbooks = friends.reduce(function(prev, curr) &#123;</span><br><span class="line">  return [...prev, ...curr.books];</span><br><span class="line">&#125;, [&apos;Alphabet&apos;]);</span><br><span class="line"></span><br><span class="line">// allbooks = [</span><br><span class="line">//   &apos;Alphabet&apos;, &apos;Bible&apos;, &apos;Harry Potter&apos;, &apos;War and peace&apos;, </span><br><span class="line">//   &apos;Romeo and Juliet&apos;, &apos;The Lord of the Rings&apos;,</span><br><span class="line">//   &apos;The Shining&apos;</span><br><span class="line">// ]</span><br></pre></td></tr></table></figure>
<h5 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h5><p><strong><br>注意： 如果你正在使用一个可以兼容<code>Set </code>和<code> Array.from() </code>的环境， 你可以使用<code>let orderedArray = Array.from(new Set(myArray)); <code>来获得一个相同元素被移除的数组。<br></code></code></strong><br>方法一：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myArray = [&apos;a&apos;, &apos;b&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;e&apos;, &apos;e&apos;, &apos;c&apos;, &apos;d&apos;, &apos;d&apos;, &apos;d&apos;, &apos;d&apos;];</span><br><span class="line">var myOrderedArray = myArray.reduce(function (accumulator, currentValue) &#123;</span><br><span class="line">  if (accumulator.indexOf(currentValue) === -1) &#123;</span><br><span class="line">    accumulator.push(currentValue);</span><br><span class="line">  &#125;</span><br><span class="line">  return accumulator</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure></p>
<p>方法二：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1,2,1,2,3,5,4,5,3,4,4,4,4];</span><br><span class="line">let result = arr.sort().reduce((init, current) =&gt; &#123;</span><br><span class="line">    if(init.length === 0 || init[init.length-1] !== current) &#123;</span><br><span class="line">        init.push(current);</span><br><span class="line">    &#125;</span><br><span class="line">    return init;</span><br><span class="line">&#125;, []);</span><br><span class="line">console.log(result); //[1,2,3,4,5]</span><br></pre></td></tr></table></figure></p>
<h5 id="按顺序运行Promise"><a href="#按顺序运行Promise" class="headerlink" title="按顺序运行Promise"></a>按顺序运行Promise</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Runs promises from array of functions that can return promises</span><br><span class="line"> * in chained manner</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;array&#125; arr - promise arr</span><br><span class="line"> * @return &#123;Object&#125; promise object</span><br><span class="line"> */</span><br><span class="line">function runPromiseInSequence(arr, input) &#123;</span><br><span class="line">  return arr.reduce(</span><br><span class="line">    (promiseChain, currentFunction) =&gt; promiseChain.then(currentFunction),</span><br><span class="line">    Promise.resolve(input)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise function 1</span><br><span class="line">function p1(a) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(a * 5);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise function 2</span><br><span class="line">function p2(a) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(a * 2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// function 3  - will be wrapped in a resolved promise by .then()</span><br><span class="line">function f3(a) &#123;</span><br><span class="line"> return a * 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise function 4</span><br><span class="line">function p4(a) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(a * 4);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const promiseArr = [p1, p2, f3, p4];</span><br><span class="line">runPromiseInSequence(promiseArr, 10)</span><br><span class="line">  .then(console.log);   // 1200</span><br></pre></td></tr></table></figure>
<h5 id="功能型函数管道"><a href="#功能型函数管道" class="headerlink" title="功能型函数管道"></a>功能型函数管道</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Building-blocks to use for composition</span><br><span class="line">const double = x =&gt; x + x;</span><br><span class="line">const triple = x =&gt; 3 * x;</span><br><span class="line">const quadruple = x =&gt; 4 * x;</span><br><span class="line"></span><br><span class="line">// Function composition enabling pipe functionality</span><br><span class="line">const pipe = (...functions) =&gt; input =&gt; functions.reduce(</span><br><span class="line">    (acc, fn) =&gt; fn(acc),</span><br><span class="line">    input</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// Composed functions for multiplication of specific values</span><br><span class="line">const multiply6 = pipe(double, triple);</span><br><span class="line">const multiply9 = pipe(triple, triple);</span><br><span class="line">const multiply16 = pipe(quadruple, quadruple);</span><br><span class="line">const multiply24 = pipe(double, triple, quadruple);</span><br><span class="line"></span><br><span class="line">// Usage</span><br><span class="line">multiply6(6); // 36</span><br><span class="line">multiply9(9); // 81</span><br><span class="line">multiply16(16); // 256</span><br><span class="line">multiply24(10); // 240</span><br></pre></td></tr></table></figure>
<h5 id="使用-reduce实现map"><a href="#使用-reduce实现map" class="headerlink" title="使用 reduce实现map"></a>使用 reduce实现map</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!Array.prototype.mapUsingReduce) &#123;</span><br><span class="line">  Array.prototype.mapUsingReduce = function(callback, thisArg) &#123;</span><br><span class="line">    return this.reduce(function(mappedArray, currentValue, index, array) &#123;</span><br><span class="line">      mappedArray[index] = callback.call(thisArg, currentValue, index, array);</span><br><span class="line">      return mappedArray;</span><br><span class="line">    &#125;, []);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[1, 2, , 3].mapUsingReduce(</span><br><span class="line">  (currentValue, index, array) =&gt; currentValue + index + array.length</span><br><span class="line">); // [5, 7, , 10]</span><br></pre></td></tr></table></figure>
<p>总之，reduce 方法功能十分强大，以后在项目中多多使用吧。😁</p>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>reduce</tag>
      </tags>
  </entry>
  <entry>
    <title>JS类型判断</title>
    <url>/2020/04/14/JS%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<p>我们都知道 JS 是弱类型语言，跟java等强类型语言不同，我们只能在运行时才真正知道某个变量是属于哪一种类型，因为在此之前，你可能有意无意的改变了变量的类型，因为变量的值及其数据类型可在声明周期内改变，这也是bug的来源，相信很多小伙伴都深有体会😆。<br><a id="more"></a></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>我们都知道，JS 中变量分为两种类型。基本类型和引用类型。</p>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>基本类型包括<code>Undefined、Null、String、Number、Boolean、Symbol</code>。基本类型按值访问，所以我们可操作保存在变量中实际的值。</p>
<p>基本类型的值在内存中占据固定大小的空间，是被保存在栈内存中。从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本，这两个值完全独立地存放在栈内存中。</p>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>引用类型是对象类型，包括<code>Object、Array、Function、Data、Regexp、Error</code>。引用类型的值是保存在堆内存中的对象，JS不允许直接访问内存中的位置，也就是说不能直接访问操作对象的内存空间。</p>
<p>操作对象时，实际上是在操作对象的引用，所以说引用类型的值是按引用访问的。从而有<code>[1, 2] === [1, 2]</code>为<code>false</code>。</p>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>js类型</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode算法题之两数之和</title>
    <url>/2019/01/09/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E4%B9%8B%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br><a id="more"></a><br>示例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line"></span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure></p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>我的解答，简单暴力。。</p>
<h4 id="解答一"><a href="#解答一" class="headerlink" title="解答一"></a>解答一</h4><ul>
<li>时间复杂度：O(n^2)， 对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。因此时间复杂度为 O(n^2)。</li>
<li>空间复杂度：O(1)</li>
<li>执行时间 148ms<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var twoSum = function(nums, target) &#123;</span><br><span class="line">    let length = nums.length;</span><br><span class="line">    for(let i = 0; i &lt;length; i++)&#123;</span><br><span class="line">        for(let j = i+1; j &lt; length; j++)&#123;</span><br><span class="line">            if(nums[i] + nums[j] === target)&#123;</span><br><span class="line">                return [i,j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="解答二"><a href="#解答二" class="headerlink" title="解答二"></a>解答二</h4><p>用es6的Map , 遍历一次即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var twoSum = function(nums, target) &#123;</span><br><span class="line">    let targetMap = new Map()</span><br><span class="line">    for (let i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">      const key = target - nums[i]</span><br><span class="line">      if (targetMap.has(key)) &#123;</span><br><span class="line">        return [targetMap.get(key), i]</span><br><span class="line">      &#125;</span><br><span class="line">      targetMap.set(nums[i], i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>两数之和</tag>
      </tags>
  </entry>
  <entry>
    <title>github actions 前端部署服务器</title>
    <url>/2021/07/04/github-actions-%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>前端每次部署都要手动打包感觉好麻烦，浪费了大量时间不说还容易出错。所以就研究了一下github 的github actions。github自己推出的持续集成工具。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: Blog CI/CD</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - master  # 只在master上push触发部署</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build-production:</span><br><span class="line"></span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    strategy:</span><br><span class="line">      matrix:</span><br><span class="line">        node-version: [12.x] # 配置所需node版本</span><br><span class="line">    steps:  # 自动化步骤</span><br><span class="line">    - uses: actions/checkout@v2   # 第一步，检出仓库副本</span><br><span class="line"></span><br><span class="line">    - name: Use Node.js $&#123;&#123; matrix.node-version &#125;&#125; #规定node.js版本(可不配置)</span><br><span class="line">      uses: actions/setup-node@v1</span><br><span class="line">      with:</span><br><span class="line">        node-version: $&#123;&#123; matrix.node-version &#125;&#125;</span><br><span class="line"></span><br><span class="line">    - name: Install dependencies  # 第二步，安装依赖</span><br><span class="line">      run: npm install</span><br><span class="line"></span><br><span class="line">    - name: Build                 # 第三步，打包代码</span><br><span class="line">      run: npm run build --if-present</span><br><span class="line"></span><br><span class="line">    # Deploy</span><br><span class="line">    - name: Deploy</span><br><span class="line">      uses: easingthemes/ssh-deploy@v2.0.7</span><br><span class="line">      env:</span><br><span class="line">        SSH_PRIVATE_KEY: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125; # 服务端私钥</span><br><span class="line">        ARGS: &quot;-avz --delete&quot;</span><br><span class="line">        SOURCE: &quot;dist/&quot;</span><br><span class="line">        REMOTE_HOST: $&#123;&#123; secrets.SSH_HOST &#125;&#125;</span><br><span class="line">        REMOTE_USER: $&#123;&#123; secrets.SSH_USERNAME &#125;&#125;</span><br><span class="line">        TARGET: $&#123;&#123; secrets.TARGET &#125;&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>CI</tag>
        <tag>部署</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title>js 单引号替换成双引号,双引号替换成单引号</title>
    <url>/2021/03/25/js-%E5%8D%95%E5%BC%95%E5%8F%B7%E6%9B%BF%E6%8D%A2%E6%88%90%E5%8F%8C%E5%BC%95%E5%8F%B7-%E5%8F%8C%E5%BC%95%E5%8F%B7%E6%9B%BF%E6%8D%A2%E6%88%90%E5%8D%95%E5%BC%95%E5%8F%B7/</url>
    <content><![CDATA[<p>js方法传参<code>data</code>中有双引号时，会报错。比如以下代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;&lt;a href=&quot;#&quot; style=&quot;text-decoration: none;color: #7b7de5;margin-left: 10px&quot; onclick=&quot;handleAcClick(&apos;+data+&apos;)&quot;&gt;回执信息&lt;/a&gt;&apos;</span><br></pre></td></tr></table></figure></p>
<p>可以把参数中的双引号转换为单引号：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JSON.stringify(data).replace(/\&quot;/g,&quot;&apos;&quot;)</span><br></pre></td></tr></table></figure></p>
<p>最后使用参数的时候再把单引号转换为双引号就行了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JSON.parse(data.replace(/&apos;/g, &apos;&quot;&apos;))</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>rails单元测试github actions</title>
    <url>/2021/07/08/rails%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95github-actions/</url>
    <content><![CDATA[<p>学 rails 时用到了单元测试，那就用 github actions 来跑测试吧。</p>
<p>下面是workflow配置：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: Ruby</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches: [ master ]</span><br><span class="line">  pull_request:</span><br><span class="line">    branches: [ master ]</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  test:</span><br><span class="line"></span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line"></span><br><span class="line">    services:</span><br><span class="line">      mysql:</span><br><span class="line">        image: mysql:5.7</span><br><span class="line">        env:</span><br><span class="line">          MYSQL_ROOT_PASSWORD: root</span><br><span class="line">          MYSQL_DATABASE: app_db_test</span><br><span class="line">        ports:</span><br><span class="line">          - 3306</span><br><span class="line">        options: &gt;-</span><br><span class="line">          --health-cmd=&quot;mysqladmin ping&quot;</span><br><span class="line">          --health-interval=10s</span><br><span class="line">          --health-timeout=5s</span><br><span class="line">          --health-retries=3</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">      - uses: actions/checkout@v1</span><br><span class="line"></span><br><span class="line">      - name: Set up Ruby 2.6.6</span><br><span class="line">        uses: ruby/setup-ruby@v1</span><br><span class="line">        with:</span><br><span class="line">          ruby-version: 2.6.6</span><br><span class="line"></span><br><span class="line">      - name: Gem cache</span><br><span class="line">        uses: actions/cache@v1</span><br><span class="line">        with:</span><br><span class="line">          path: vendor/bundle</span><br><span class="line">          key: $&#123;&#123; runner.os &#125;&#125;-gems-$&#123;&#123; hashFiles(&apos;**/Gemfile.lock&apos;) &#125;&#125;</span><br><span class="line">          restore-keys: |</span><br><span class="line">            $&#123;&#123; runner.os &#125;&#125;-gems-</span><br><span class="line"></span><br><span class="line">      - name: Verify MySQL connection from host</span><br><span class="line">        run: |</span><br><span class="line">          sudo apt-get install -y mysql-client libmysqlclient-dev</span><br><span class="line">          sudo /etc/init.d/mysql start</span><br><span class="line">          mysql -h 127.0.0.1 --port $&#123;&#123; job.services.mysql.ports[3306] &#125;&#125; -u root -proot -e &quot;CREATE DATABASE IF NOT EXISTS app_db_test;&quot;</span><br><span class="line"></span><br><span class="line">      - name: Bundle install, setup DB and run tests</span><br><span class="line">        env:</span><br><span class="line">          RAILS_ENV: test</span><br><span class="line">          DB_PASSWORD: root</span><br><span class="line">          DB_PORT: $&#123;&#123; job.services.mysql.ports[3306] &#125;&#125;</span><br><span class="line">        run: |</span><br><span class="line">          cp config/database.yml.ci config/database.yml</span><br><span class="line">          gem install bundler</span><br><span class="line">          bundle config path vendor/bundle</span><br><span class="line">          bundle install --jobs 4 --retry 3</span><br><span class="line">          bundle exec rails db:setup</span><br><span class="line">          bundle exec rails test</span><br></pre></td></tr></table></figure></p>
<p>database.yml.ci 配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default: &amp;default</span><br><span class="line">  adapter: mysql2</span><br><span class="line">  encoding: utf8mb4</span><br><span class="line">  pool: &lt;%= ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) &#123; 5 &#125; %&gt;</span><br><span class="line">  username: root</span><br><span class="line">  password: root</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  &lt;&lt;: *default</span><br><span class="line">  database: app_db_test</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>持续集成</tag>
        <tag>github actions</tag>
      </tags>
  </entry>
  <entry>
    <title>vps一键搭建ss脚本</title>
    <url>/2019/07/27/vps%E4%B8%80%E9%94%AE%E6%90%AD%E5%BB%BAss%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h3 id="安装脚本"><a href="#安装脚本" class="headerlink" title="安装脚本"></a>安装脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate http://down.whsir.com/downloads/shadowsocks-go.sh</span><br><span class="line">chmod +x shadowsocks-go.sh</span><br><span class="line">./shadowsocks-go.sh 2&gt;&amp;1 | tee shadowsocks-go.log</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="卸载方法"><a href="#卸载方法" class="headerlink" title="卸载方法"></a>卸载方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./shadowsocks-go.sh uninstall</span><br></pre></td></tr></table></figure>
<h3 id="用户密码配置"><a href="#用户密码配置" class="headerlink" title="用户密码配置"></a>用户密码配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/shadowsocks/config.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,  //你的主机IP</span><br><span class="line">    &quot;server_port&quot;:xxxx,  //端口</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;password&quot;:&quot;xxxx&quot;,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class="line">    &quot;timeout&quot;:600</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/init.d/shadowsocks restart</span><br></pre></td></tr></table></figure>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动：/etc/init.d/shadowsocks start</span><br><span class="line">停止：/etc/init.d/shadowsocks stop</span><br><span class="line">重启：/etc/init.d/shadowsocks restart</span><br><span class="line">状态：/etc/init.d/shadowsocks status</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>vps</tag>
        <tag>ss</tag>
      </tags>
  </entry>
  <entry>
    <title>事件捕获,冒泡,代理</title>
    <url>/2022/01/26/%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7-%E5%86%92%E6%B3%A1-%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>事件冒泡： 事件默认是由下往上的冒泡执行方式。以点击事件为例，当我们点击子元素也能触发父元素及以上元素的点击事件。事件执行顺序由下至上，这就是冒泡事件</p>
<p>事件捕获：执行方式是由上往下的捕获方式。还是以点击事件为例，当一个子元素绑定了点击事件，我们点击子元素时，父元素及以上的元素绑定的点击事件也会执行。事件的执行顺序时由上至下，这就是捕获事件</p>
<a id="more"></a>
<p>事件代理： 事件代理是基于事件冒泡，当我们点击子元素也能触发父元素及以上元素的点击事件，所以可以通过给父元素添加事件函数，通过判断当前点击的是不是子元素来添加一些处理。 这样我么就不用给每一个子元素添加事件，对于动态添加的子元素也适用。</p>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>事件捕获</tag>
        <tag>事件冒泡</tag>
      </tags>
  </entry>
  <entry>
    <title>优化打包体积</title>
    <url>/2022/01/24/%E4%BC%98%E5%8C%96%E6%89%93%E5%8C%85%E4%BD%93%E7%A7%AF/</url>
    <content><![CDATA[<p>最近发现项目打包体积竟然有20M了， 想了想项目确实有几张图片体积很大，还引入了echarts， 但不至于体积这么大吧，于是开始研究webpack打包了。<br><a id="more"></a><br>首先安装<code></code>webpack-bundle-analyzer` 插件， 找出最占用空间的文件有哪些。</p>
<p><code>npm install webpack-bundle-analyzer -D</code></p>
<p>我是用的<code>vue-cli4</code>， 所以在<code>vue.config.js</code>里面添加如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const BundleAnalyzerPlugin = require(&quot;webpack-bundle-analyzer&quot;).BundleAnalyzerPlugin;</span><br><span class="line"> </span><br><span class="line">// 展示图形化信息</span><br><span class="line">chainWebpack: config =&gt; &#123;</span><br><span class="line">  config</span><br><span class="line">    .plugin(&apos;webpack-bundle-analyzer&apos;)</span><br><span class="line">    .use(BundleAnalyzerPlugin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在<code>package.json</code>里面添加<code>&quot;analyzer&quot;: &quot;use_analyzer=true npm run serve&quot;</code><br>可以看到如下图：</p>
<p><img src="https://static01.imgkr.com/temp/8589678b5bcd43cc9107f90eb60f701e.jpg" alt="&#39;打包分析&#39;"></p>
<p>可以看到，echarts 可以说是罪魁祸首了，源码加上地图json文件，占用了很大一部分空间。elementUI的文件也很大。</p>
<p>首先是elementUI 的按需加载：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    &apos;@vue/app&apos;</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      &quot;component&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        libraryName: &quot;element-ui&quot;,</span><br><span class="line">        styleLibraryName: &quot;theme-chalk&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着优化echarts按需加载：<br><code>npm install babel-plugin-equire -D</code></p>
<figure class="highlight plain"><figcaption><span>echarts </span></figcaption><table><tr><td class="code"><pre><span class="line">  // 写上你需要的 echarts api</span><br><span class="line">  &quot;bar&quot;,</span><br><span class="line">  &quot;line&quot;,</span><br><span class="line">  &quot;map&quot;</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">export default echarts;</span><br></pre></td></tr></table></figure>
<p>在<code>vue.config.js</code>里面添加<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    &apos;@vue/app&apos;</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      &quot;component&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        libraryName: &quot;element-ui&quot;,</span><br><span class="line">        styleLibraryName: &quot;theme-chalk&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;equire&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>页面应用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 直接引用</span><br><span class="line"> import echarts from &apos;@/lib/util/echarts.js&apos; </span><br><span class="line"> </span><br><span class="line"> this.myChart = echarts.init(this.$refs.chart)</span><br></pre></td></tr></table></figure></p>
<p>删除无用的插件，避免加载多余的资源<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chainWebpack: config =&gt; &#123;</span><br><span class="line">    // 移除prefetch插件，避免加载多余的资源</span><br><span class="line">    config.plugins.delete(&apos;prefetch&apos;)</span><br><span class="line">    / 移除 preload 插件，避免加载多余的资源</span><br><span class="line">    config.plugins.delete(&apos;preload&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>图片按需加载:  <code>npm install image-webpack-loader -D</code><br><code>vue.config.js</code>里面：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config.module.rule(&apos;images&apos;)</span><br><span class="line">    .test(/\.(png|jpe?g|gif|webp)(\?.*)?$/)</span><br><span class="line">    .use(&apos;image-webpack-loader&apos;)</span><br><span class="line">    .loader(&apos;image-webpack-loader&apos;)</span><br><span class="line">    .options(&#123;</span><br><span class="line">      bypassOnDebug: true</span><br><span class="line">    &#125;)</span><br><span class="line">    .end()</span><br></pre></td></tr></table></figure></p>
<p>抽离 css 支持按需加载: <code>npm install mini-css-extract-plugin -D</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chainWebpack: config =&gt; &#123;</span><br><span class="line">  let miniCssExtractPlugin = new MiniCssExtractPlugin(&#123;</span><br><span class="line">    filename: &apos;assets/[name].[hash:8].css&apos;,</span><br><span class="line">    chunkFilename: &apos;assets/[name].[hash:8].css&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">  config.plugin(&apos;extract-css&apos;).use(miniCssExtractPlugin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>gzip压缩代码: <code>npm install compression-webpack-plugin -D</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">// 开启gzip压缩</span><br><span class="line">  config.plugins.push(</span><br><span class="line">    new CompressionWebpackPlugin(</span><br><span class="line">      &#123;</span><br><span class="line">        filename: info =&gt; &#123;</span><br><span class="line">          return `$&#123;info.path&#125;.gz$&#123;info.query&#125;`</span><br><span class="line">        &#125;,</span><br><span class="line">        algorithm: &apos;gzip&apos;,</span><br><span class="line">        threshold: 10240, // 只有大小大于该值的资源会被处理 10240</span><br><span class="line">        test: new RegExp(&apos;\\.(&apos; + [&apos;js&apos;].join(&apos;|&apos;) + &apos;)$&apos;</span><br><span class="line">        ),</span><br><span class="line">        minRatio: 0.8, // 只有压缩率小于这个值的资源才会被处理</span><br><span class="line">        deleteOriginalAssets: false // 删除原文件</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>webpack</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title>前端下载 excel</title>
    <url>/2021/07/02/%E5%89%8D%E7%AB%AF%E4%B8%8B%E8%BD%BD-excel/</url>
    <content><![CDATA[<p>前端导出excel:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import XLSX from &apos;xlsx&apos;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 导出Excel的处理函数--针对table</span><br><span class="line"> * @param &#123;Array&#125; headers: [&#123;key: &apos;date&apos;, title: &apos;日期&apos;&#125;, &#123;key: &apos;name&apos;, title: &apos;名称&apos;&#125;]</span><br><span class="line"> * @param &#123;Array&#125; data   : [&#123;date: &apos;2019-05-31&apos;, name: &apos;megen.huang&apos;&#125;, &#123;date: &apos;name&apos;, name: &apos;小明&apos;&#125;]</span><br><span class="line"> * @param &#123;String&#125; fileName: &apos;导出结果.xlsx&apos;</span><br><span class="line"> * */</span><br><span class="line">export default function Export2Excel (headers, data, fileName = &apos;导出结果.xlsx&apos;) &#123;</span><br><span class="line">  const _headers = headers.map((item, i) =&gt; Object.assign(&#123;&#125;, &#123; key: item.key, title: item.title, position: String.fromCharCode(65 + i) + 1 &#125;)).reduce((prev, next) =&gt; Object.assign(&#123;&#125;, prev, &#123; [next.position]: &#123; key: next.key, v: next.title &#125; &#125;), &#123;&#125;)</span><br><span class="line"></span><br><span class="line">  const _data = data.map((item, i) =&gt; headers.map((key, j) =&gt; Object.assign(&#123;&#125;, &#123; content: item[key.key], position: String.fromCharCode(65 + j) + (i + 2) &#125;)))</span><br><span class="line">  // 对刚才的结果进行降维处理（二维数组变成一维数组）</span><br><span class="line">    .reduce((prev, next) =&gt; prev.concat(next))</span><br><span class="line">    // 转换成 worksheet 需要的结构</span><br><span class="line">    .reduce((prev, next) =&gt; Object.assign(&#123;&#125;, prev, &#123; [next.position]: &#123; v: next.content &#125; &#125;), &#123;&#125;)</span><br><span class="line"></span><br><span class="line">  // 合并 headers 和 data</span><br><span class="line">  const output = Object.assign(&#123;&#125;, _headers, _data)</span><br><span class="line">  // 获取所有单元格的位置</span><br><span class="line">  const outputPos = Object.keys(output)</span><br><span class="line">  // 计算出范围 ,[&quot;A1&quot;,..., &quot;H2&quot;]</span><br><span class="line">  const ref = `$&#123;outputPos[0]&#125;:$&#123;outputPos[outputPos.length - 1]&#125;`</span><br><span class="line">  // 构建 workbook 对象</span><br><span class="line">  const wb = &#123;</span><br><span class="line">    SheetNames: [&apos;mySheet&apos;],</span><br><span class="line">    Sheets: &#123;</span><br><span class="line">      mySheet: Object.assign(</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">        output,</span><br><span class="line">        &#123;</span><br><span class="line">          &apos;!ref&apos;: ref,</span><br><span class="line">          // eslint-disable-next-line</span><br><span class="line">            &apos;!cols&apos;: headers.map(item =&gt; (&#123;wpx: 100&#125;))</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 导出 Excel</span><br><span class="line">  XLSX.writeFile(wb, fileName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>加油!</title>
    <url>/2022/02/12/%E5%8A%A0%E6%B2%B9/</url>
    <content><![CDATA[<p>最近面试不太顺利，再一次感叹平时真的没有好好准备，遇到好的工作机会最后只能感叹，机会是留给有准备的人的。<br>不过，不要气馁，加油吧！好好总结，接着干！！！</p>
<p>很久没有写日记了，感觉可以经常写写，记录平时的一些感想，多年后再看应该很有趣吧😁</p>
]]></content>
  </entry>
  <entry>
    <title>多条件判断的另一种写法</title>
    <url>/2020/02/23/%E5%A4%9A%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<p>在写业务逻辑到时候，我们经常会碰到写很多if, 少数还好，多个的话可能会用switch, 随着业务逻辑越来越复杂，代码可能越来越臃肿，这个时候我们需要另一种写法简化代码。<br><a id="more"></a></p>
<h3 id="ES6-Map"><a href="#ES6-Map" class="headerlink" title="ES6 Map"></a>ES6 Map</h3><p>从阮一峰老师的基础教程里可以知道 Map 的大致用法： </p>
<p>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const m = new Map();</span><br><span class="line">const o = &#123;p: &apos;Hello World&apos;&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, &apos;content&apos;)</span><br><span class="line">m.get(o) // &quot;content&quot;</span><br><span class="line"></span><br><span class="line">m.has(o) // true</span><br><span class="line">m.delete(o) // true</span><br><span class="line">m.has(o) // false</span><br></pre></td></tr></table></figure>
<p>上面代码使用 Map 结构的set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。</p>
<p>上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">  [&apos;name&apos;, &apos;张三&apos;],</span><br><span class="line">  [&apos;title&apos;, &apos;Author&apos;]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size // 2</span><br><span class="line">map.has(&apos;name&apos;) // true</span><br><span class="line">map.get(&apos;name&apos;) // &quot;张三&quot;</span><br><span class="line">map.has(&apos;title&apos;) // true</span><br><span class="line">map.get(&apos;title&apos;) // &quot;Author&quot;</span><br></pre></td></tr></table></figure>
<p>利用以上这一点，我们就可以重构多个 if 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//将判断条件作为对象的属性名，将处理逻辑作为对象的属性值</span><br><span class="line">var Statistics = function()&#123;</span><br><span class="line">  console.log(&apos;执行&apos;)</span><br><span class="line">&#125;</span><br><span class="line">const comparativeTotles = new Map([</span><br><span class="line">    [0,Statistics],</span><br><span class="line">    [1,Statistics],</span><br><span class="line">    [2,Statistics],</span><br><span class="line">    [3,Statistics]</span><br><span class="line"> ])</span><br><span class="line">let map = function(val)&#123;</span><br><span class="line">      return comparativeTotles.get(val)</span><br><span class="line">&#125; </span><br><span class="line">let getMap  = map(1); //如果查找不到返回undefined</span><br><span class="line">if(!getMap)&#123;</span><br><span class="line">      console.log(&apos;查找不到&apos;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    concaozuole.log(&apos;执行操作&apos;)</span><br><span class="line">      getMap()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>根据子节点寻找父节点路径</title>
    <url>/2020/05/03/%E6%A0%B9%E6%8D%AE%E5%AD%90%E8%8A%82%E7%82%B9%E5%AF%BB%E6%89%BE%E7%88%B6%E8%8A%82%E7%82%B9%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>最近项目遇到一个需求，在一个树结构里，根据子节点寻找父节点的路径，这里记录一下。<br><a id="more"></a></p>
<h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getParent(array, nodeCode)&#123;</span><br><span class="line">  let stack = [];</span><br><span class="line">  let going = true;</span><br><span class="line">  </span><br><span class="line">  let walker = (array, nodeCode) =&gt; &#123;</span><br><span class="line">      array.forEach(item =&gt; &#123;</span><br><span class="line">          if (!going) return;</span><br><span class="line">          stack.push(item[&apos;nodeCode&apos;]);</span><br><span class="line">          if (item[&apos;nodeCode&apos;] === nodeCode) &#123;</span><br><span class="line">              going = false;</span><br><span class="line">          &#125; else if (item[&apos;child&apos;]) &#123;</span><br><span class="line">              walker(item[&apos;child&apos;], nodeCode);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              stack.pop();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      if (going) stack.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  walker(array, nodeCode);</span><br><span class="line"></span><br><span class="line">  return stack.join(&apos;,&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getParent(data, target)&#123;</span><br><span class="line"></span><br><span class="line">  const get = (children, target, record = []) =&gt; (</span><br><span class="line">    children.reduce((result, &#123; nodeCode, child: innerChildren &#125;) =&gt; &#123;</span><br><span class="line">      if (nodeCode === target) &#123;</span><br><span class="line">        return [...record, target]</span><br><span class="line">      &#125;</span><br><span class="line">      if (innerChildren) &#123;</span><br><span class="line">        return [...result, ...get(innerChildren, target, [...record, nodeCode])]</span><br><span class="line">      &#125;</span><br><span class="line">      return result</span><br><span class="line">    &#125;, []))</span><br><span class="line"></span><br><span class="line">  return get(data, target).join(&apos;,&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>测试持续集成</title>
    <url>/2020/09/27/%E6%B5%8B%E8%AF%95%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<p>添加了travis的一个脚本，这样每次只要提交一下博客文件就行了，打包的工作就交还给travis了。持续集成真的很好用，极大地提升了效率。</p>
]]></content>
      <tags>
        <tag>持续集成</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之数组(一)</title>
    <url>/2020/04/25/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84-%E4%B8%80/</url>
    <content><![CDATA[<p>给定一个数组，排序后实现第一大的值放在最左边，同时把第二大的值放在最右边，第三大的值放在左边第二位，第四大的值放在右边第二位，依次排序，比如给定<code>[1, 2, 3, 4]</code>，期望结果: <code>[4, 2, 1, 3]</code><br><a id="more"></a></p>
<h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><p>先把数组降序，然后索引为偶数的放左边，为奇数的放右边</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sortArr = (nums) =&gt; &#123;</span><br><span class="line">  let arr = nums.sort((x,y) =&gt; &#123;</span><br><span class="line">    return y - x</span><br><span class="line">  &#125;)</span><br><span class="line">  let a= []</span><br><span class="line">  let b = []</span><br><span class="line">  arr.forEach((element,i) =&gt; &#123;</span><br><span class="line">    if(i%2 === 0)&#123;</span><br><span class="line">      a.push(element)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      b.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return a.concat(b.reverse())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sortArr([2,1,4,100,50,13,8,6,23]))//[ 100, 23,  8,  4, 1, 2,  6, 13, 50 ]</span><br></pre></td></tr></table></figure>
<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>分别从数组的头和尾迭代数组，找出最大值，并与之交换位置，继续在剩下的数组里重复上一步做法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const getArrMaxIndex = (nums,start,end) =&gt; &#123;</span><br><span class="line">  const max = Math.max.apply(null, nums.slice(start,end))</span><br><span class="line">  return nums.findIndex(i=&gt;i===max)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">const sortArr = (nums) =&gt; &#123;</span><br><span class="line">  let [start, temp, end] = [0, 1, nums.length]</span><br><span class="line">  while(start !== end-1)&#123;</span><br><span class="line">    let maxIndex = getArrMaxIndex(nums,start,end)</span><br><span class="line">    if(temp%2 === 0)&#123;</span><br><span class="line">      [nums[end-1], nums[maxIndex]] = [nums[maxIndex], nums[end-1]]</span><br><span class="line">      end--</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      [nums[start], nums[maxIndex]] = [nums[maxIndex], nums[start]]</span><br><span class="line">      start++</span><br><span class="line">    &#125;</span><br><span class="line">    temp++</span><br><span class="line">  &#125;</span><br><span class="line">  return nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sortArr([2,1,4,100,50,13,8,6,23]))//[ 100, 23,  8,  4, 1, 2,  6, 13, 50 ]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>终于看完老友记了</title>
    <url>/2020/04/12/%E7%BB%88%E4%BA%8E%E7%9C%8B%E5%AE%8C%E8%80%81%E5%8F%8B%E8%AE%B0%E4%BA%86/</url>
    <content><![CDATA[<p><img src="https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1586704138&amp;di=4329bb6a517364a9577b7c3f3bae641e&amp;src=http://i2.hdslb.com/bfs/archive/5339b0aee51f6be61ff127d1a7f9e085ca893104.jpg" alt="&#39;老友记海报&#39;"></p>
<p>大学时就开始看老友记了，但是断断续续看了几季后又没看了，直到今天终于看完。看完发现，老友记真的好多荤段子啊😝，真的是少儿不宜2333。最开始我看海报，就是上面这张，我以为乔伊会和菲比在一起，最后看完竟然不是，哈哈哈哈。总之看完还是有点伤感的，有追完剧的空虚，也想起了大学时代那些日子，时间过得可真快啊。。。</p>
]]></content>
      <tags>
        <tag>老友记</tag>
        <tag>美剧</tag>
      </tags>
  </entry>
  <entry>
    <title>递归实现1-100求和</title>
    <url>/2022/02/12/%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B01-100%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<p>面试遇到这样一道题，平时没怎么准备算法，当时就卡壳了。后来回来想想其实很简单。要做的其实就是，用递归实现每次加1或者减1。</p>
<p>真的要好好看看算法了呀。<br><a id="more"></a><br>减1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sum(n)&#123;</span><br><span class="line">  if(n === 1) return 1</span><br><span class="line">  return sum(n - 1) + n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(100) // 5050</span><br></pre></td></tr></table></figure>
<p>加1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sum(num, start) &#123;</span><br><span class="line">  num += start</span><br><span class="line">  start++;</span><br><span class="line">  if (start &gt; 100) &#123;</span><br><span class="line">    return num</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    sum(num, start)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">sum(0, 1) // 5050</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>锚点导航</title>
    <url>/2021/03/16/%E9%94%9A%E7%82%B9%E5%AF%BC%E8%88%AA/</url>
    <content><![CDATA[<p>导航锚点跟随页面滚动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;#work_info&quot;).on(&apos;scroll&apos;, function ()&#123;</span><br><span class="line">    var flag = 0;</span><br><span class="line">    var w_top = $(this).scrollTop();</span><br><span class="line">    var len = arr.length</span><br><span class="line">    for(var i=0;i&lt;len;i++)&#123;</span><br><span class="line">        var linkText = arr[i];</span><br><span class="line">            if(w_top &gt;= topObj[linkText] &amp;&amp; w_top &lt;= topObj[[arr[i+1]]])&#123;</span><br><span class="line">                flag = i</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (topObj[arr[flag+1]] - w_top &lt; w_top -  topObj[arr[flag]])&#123;</span><br><span class="line">        flag += 1</span><br><span class="line">    &#125;</span><br><span class="line">    if (w_top &gt; arr[len - 1]) &#123;</span><br><span class="line">        flag = len - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    $(&apos;.anchor-link[value=&apos;+arr[flag]+&apos;]&apos;).siblings().removeClass(&apos;anchor-active&apos;);</span><br><span class="line">    $(&apos;.anchor-link[value=&apos;+arr[flag]+&apos;]&apos;).addClass(&apos;anchor-active&apos;)                     </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖节流</title>
    <url>/2022/02/12/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p>在处理高频事件，类似于window的resize或者scorll，或者input输入校验等操作时。如果直接执行事件处理器，会增大浏览器的负担，严重的直接卡死，用户体验非常不好。</p>
<p>面对这种情况，我们一般可以采用防抖和节流的方式减少调用频率。<br><a id="more"></a><br>防抖：在单位时间内执行函数， 如果在这个时间内触发，则重新开始计时。<br>场景：滚动条滚动， 提交按钮</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debounce(fn, delay)&#123;</span><br><span class="line">  let timer</span><br><span class="line">  return function()&#123;</span><br><span class="line">    if(timer) clearTimeout(timer)</span><br><span class="line"></span><br><span class="line">    timer = setTimeout(fn, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>防抖：在单位时间内执行函数， 如果在这个时间内触发，则忽略，直到时间结束，函数开始执行<br>场景：输入框输入</p>
<p>第一种实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle(fn, delay)&#123;</span><br><span class="line">  let timer</span><br><span class="line">  return function()&#123;</span><br><span class="line">    if(timer) return</span><br><span class="line">    timer = setTimeout(function()&#123;</span><br><span class="line">      fn()</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle(fn, delay)&#123;</span><br><span class="line">  let prev = Date.now()</span><br><span class="line">  return function()&#123;</span><br><span class="line">    if(Date.now() - prev &lt; delay) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    fn()</span><br><span class="line">    prev = Date.now()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>防抖</tag>
        <tag>节流</tag>
      </tags>
  </entry>
</search>
